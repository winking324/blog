<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://winking324.github.io</id>
    <title>Winking</title>
    <updated>2021-12-22T02:05:19.570Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://winking324.github.io"/>
    <link rel="self" href="https://winking324.github.io/atom.xml"/>
    <subtitle>还愣着干啥！点赞啊！</subtitle>
    <logo>https://winking324.github.io/images/avatar.png</logo>
    <icon>https://winking324.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Winking</rights>
    <entry>
        <title type="html"><![CDATA[金字塔原理要点汇总]]></title>
        <id>https://winking324.github.io/post/the-minto-pyramid-principle/</id>
        <link href="https://winking324.github.io/post/the-minto-pyramid-principle/">
        </link>
        <updated>2021-11-29T01:43:54.000Z</updated>
        <summary type="html"><![CDATA[<p>读完了号称“美团四大名著”之一的《金字塔原理》，总结一句话：食之无味弃之可惜。为什么这么说呢？书中介绍的方法论非常值得学习，但是不知是否翻译原因，整书内容枯燥乏味，一本介绍如何写文章的书却写成这样，实在可惜。</p>
]]></summary>
        <content type="html"><![CDATA[<p>读完了号称“美团四大名著”之一的《金字塔原理》，总结一句话：食之无味弃之可惜。为什么这么说呢？书中介绍的方法论非常值得学习，但是不知是否翻译原因，整书内容枯燥乏味，一本介绍如何写文章的书却写成这样，实在可惜。</p>
<!-- more -->
<h1 id="第1章-为什么要用金字塔结构">第1章 为什么要用金字塔结构</h1>
<ol>
<li>为了交流方便，必须将思想（观点、结论、要点、论点、论据、建议、行动、步骤等）归类分组；</li>
<li>将分组后的思想按照不同层次进行抽象提炼、总结概括，构建金字塔结构；</li>
<li>向读者介绍（传递、阐述、论证）思想最有效的途径是结论先行，自上而下地表达；</li>
<li>金字塔中的思想应遵守 3 个基本原则；</li>
<li>要做到条理清晰，关键是把思想组织成金字塔结构，并在写作前用金字塔原理检查；</li>
</ol>
<h2 id="关键概念">关键概念</h2>
<h3 id="金字塔结构的-3-个基本原则">金字塔结构的 3 个基本原则</h3>
<ul>
<li>结论先行：每篇文章只有一个中心思想，且应放在文章的最前面；</li>
<li>以上统下：每一层次的思想必须是对下一层次思想的总结概括；</li>
<li>归类分组：每一组中的思想必须属于同一逻辑范畴；</li>
<li>逻辑递进：每一组中的思想必须按照逻辑顺序排列；</li>
</ul>
<h1 id="第2章-金字塔内部的结构">第2章 金字塔内部的结构</h1>
<ol>
<li>金字塔结构的各个层级包括各种思想，思想使受众（包括读者、听众、观众或学员）产生疑问；</li>
<li>在纵向上，各层级思想将与读者进行疑问-回答式对话；</li>
<li>在横向上，各种思想以演绎推理或归纳推理的方式回答读者的疑问，但两种方式不可同时使用；</li>
<li>序言通过讲故事提醒读者，文章将回答读者最初的疑问；</li>
<li>序言包括背景、冲突、读者的疑问和作者的回答。冲突因背景而产生，背景和冲突都是读者已知的事实；</li>
<li>冲突导致读者提出疑问，而文章将回答读者的疑问；</li>
</ol>
<h2 id="关键概念-2">关键概念</h2>
<h3 id="金字塔结构中的逻辑关系">金字塔结构中的逻辑关系</h3>
<ul>
<li>各种思想纵向相关（疑问-回答式对话）；</li>
<li>各种思想横向相关（演绎/归纳）；</li>
<li>金字塔顶端思想回答读者心中已有的疑问；</li>
<li>序言引出读者最初的疑问；</li>
</ul>
<h1 id="第3章-如何构建金字塔">第3章 如何构建金字塔</h1>
<ol>
<li>自上而下法：
<ul>
<li>确定作者想论述的主题；</li>
<li>设想读者的疑问；</li>
<li>给出答案；</li>
<li>检查背景和冲突是否引发读者提出疑问；</li>
<li>证实答案；</li>
<li>填写关键句要点；</li>
</ul>
</li>
<li>自下而上法：
<ul>
<li>列出作者想表达的所有要点；</li>
<li>找出各要点之间的关系；</li>
<li>得出结论；</li>
<li>倒推出序言；</li>
</ul>
</li>
</ol>
<h2 id="关键概念-3">关键概念</h2>
<h3 id="构建金字塔结构">构建金字塔结构</h3>
<ul>
<li>确定主题；</li>
<li>设想疑问；</li>
<li>给出答案；</li>
<li>检查背景和冲突是否会引发读者的疑问；</li>
<li>证实答案；</li>
<li>填写关键句要点；</li>
</ul>
<h1 id="第4章-序言的具体写法">第4章 序言的具体写法</h1>
<ol>
<li>序言的目的是提示读者已知的信息，而不是提供新信息；</li>
<li>序言通常包括背景、冲突、读者的疑问和作者的答案；</li>
<li>序言的长短取决于读者的需要和主题的要求；</li>
<li>为每个关键句要点写一段引言；</li>
</ol>
<h1 id="关键概念-4">关键概念</h1>
<h3 id="写序言">写序言</h3>
<ul>
<li>说明背景；</li>
<li>指出冲突；</li>
<li>冲突引发读者提出疑问；</li>
<li>文章正文给出答案；</li>
</ul>
<h1 id="第5章-演绎推理与归纳推理">第5章 演绎推理与归纳推理</h1>
<ol>
<li>演绎推理是一种论证，其中第二个论点对第一个论点加以评论，第三个论点说明前两个论点同时存在时的含义；</li>
<li>对演绎推理的概括就是把最后一个论点作为主体，概括整个推理过程；</li>
<li>归纳推理是把具有相似性的思想归类分组，根据各要点具有的共同性得出结论；</li>
<li>在关键句层次，使用归纳推理比演绎推理更方便读者理解；</li>
</ol>
<h2 id="关键概念-5">关键概念</h2>
<h3 id="逻辑推理">逻辑推理</h3>
<ul>
<li>演绎推理是一个线性推理过程；</li>
<li>归纳推理是把相似的思想或相关的行动加以归类；</li>
<li>在关键句要点层次，使用归纳推理比演绎推理更方便读者理解；</li>
</ul>
<h1 id="第6章-应用逻辑顺序">第6章 应用逻辑顺序</h1>
<ol>
<li>应用逻辑顺序可以确保你不会：
<ul>
<li>把新闻当做思想；</li>
<li>遗漏某组中的重要思想；</li>
</ul>
</li>
<li>任一组思想的逻辑顺序都呈现了该组思想的分组基础：
<ul>
<li>时间顺序：通过设想某一流程得出的思想；</li>
<li>结构顺序：通过评论某一结构得出的思想；</li>
<li>程度顺序：按程度或重要性分组得出的思想；</li>
</ul>
</li>
<li>如果你在某一组思想中找不到以上顺序，说明这些思想之间不存在逻辑关系，或者你的思考还不周全；</li>
<li>为了检查一组思想的逻辑顺序，你可以：
<ul>
<li>先把每一个句子改写成能说明其实质的短句（即只保留主语、谓语、宾语，删除定语、状语和补语，只保留动词、名词，删除形容词、副词）；</li>
<li>再把相匹配或具有共同点的句子归为一组；</li>
<li>最后选择适当的顺序排列；</li>
</ul>
</li>
<li>如果是行动性思想（即说明行动、活动、行为、动作、步骤、流程等），那么应该：
<ul>
<li>明确说明每项行动产生的最终结果（效果、目标）；</li>
<li>把最终能产生同样结果的行动（行为、步骤等）归为一组；</li>
<li>确定每组思想的分组基础（类别），并依此排序；</li>
<li>检查是否有遗漏的步骤；</li>
</ul>
</li>
<li>如果是描述性思想（即介绍观点、情况、信息等），那么应该：
<ul>
<li>把说明类似事务或具有共同点的思想归为一组；</li>
<li>确定每组思想的分组基础（找出相似之处、共同点）；</li>
<li>把所有思想转换成完整的句子，确定其顺序；</li>
<li>检查是否有遗漏的步骤；</li>
</ul>
</li>
</ol>
<h2 id="关键概念-6">关键概念</h2>
<h3 id="将行动性思想说明行动-活动-行为-步骤-流程排序">将行动性思想（说明行动、活动、行为、步骤、流程）排序</h3>
<ul>
<li>明确说明每一行动产生的最终结果；</li>
<li>把能产生相同结果的思想合并、归类、分组；</li>
<li>确定该组思想的分组基础，并依此排序；</li>
<li>检查是否有遗漏的步骤；</li>
</ul>
<h3 id="将描述性思想介绍观点-论点-论据-情况-信息排序">将描述性思想（介绍观点、论点、论据、情况、信息）排序</h3>
<ul>
<li>把说明类似事务或具有共同点的思想归类、合并、分组；</li>
<li>确定每组思想的分组基础；</li>
<li>把所有思想转换成完整的句子，确定其顺序；</li>
<li>检查是否有遗漏的步骤；</li>
</ul>
<h1 id="第7章-概括各组思想">第7章 概括各组思想</h1>
<ol>
<li>避免使用“缺乏思想”的句子（比如，存在3个问题…）；</li>
<li>分组应遵守“相互独立不重叠，完全穷尽无遗漏”原则（MECE 原则）；</li>
<li>行动总是按时间顺序进行，通过说明行动产生的直接结果可以概括行动性思想；</li>
<li>将描述性思想归类分组，是因为每组思想具有共同特性，它们都：
<ul>
<li>针对同一类主语；</li>
<li>针对同一类谓语（动作或对象）；</li>
<li>包含同一类判断；</li>
</ul>
</li>
<li>对行动性思想进行分组时，要求：
<ul>
<li>发掘每项行动的本质；</li>
<li>区分不同的抽象层次（比如，采取一项行动，只是时间上必须在另一行动之前，还是为了完成另一行动？）；</li>
<li>明确说明行动产生的最终结果；</li>
<li>直接由行动概括出结果；</li>
</ul>
</li>
<li>对描述性思想进行分组时，要求：
<ul>
<li>找出句子结构的共同点；</li>
<li>确定包括这些思想的最小范畴；</li>
<li>说明共同点隐含的意义；</li>
</ul>
</li>
</ol>
<h2 id="关键概念-7">关键概念</h2>
<h3 id="概括各组思想">概括各组思想</h3>
<ul>
<li>通过说明行动产生的直接结果，概括行动性思想（概括一组行动）；</li>
<li>通过说明各项思想具有的共同点、相似性，概括描述性思想（概括一组信息）；</li>
</ul>
<h3 id="寻找思想共同点">寻找思想共同点</h3>
<ul>
<li>各思想是否针对同一类主题；</li>
<li>各思想是否涉及同一类行动；</li>
<li>各思想是否针对同一类对象；</li>
<li>各思想是否包含同一类观点；</li>
</ul>
<h3 id="行动性思想分组">行动性思想分组</h3>
<ul>
<li>发掘每项行动的实本质；</li>
<li>区分行动的不同层次；</li>
<li>明确说明行动性思想产生的最终结果（效果、目标）；</li>
<li>直接由行动概括出结果；</li>
</ul>
<h3 id="描述性思想分组">描述性思想分组</h3>
<ul>
<li>找出主语、谓语、宾语或含义的共同点；</li>
<li>确定包括这些思想的最小范畴；</li>
<li>说明共同性隐含的意义；</li>
</ul>
<h1 id="第8章-界定问题">第8章 界定问题</h1>
<ol>
<li>展开“问题”的各要素：
<ul>
<li>切入点/序幕（产生问题的具体领域、方面）；</li>
<li>困扰/困惑（它的发生打乱了该领域的稳定）；</li>
<li>现状（R1，非期望结果）；</li>
<li>目标（R2，期望结果）；</li>
<li>答案（到目前为止，针对问题已经采取的措施，如果采取了的话）；</li>
<li>疑问（为了解决问题，必须做什么）；</li>
</ul>
</li>
<li>把界定的问题转换成序言：
<ul>
<li>从左往右再往下；</li>
<li>读者最后知道的事实就是冲突；</li>
</ul>
</li>
</ol>
<h2 id="关键概念-8">关键概念</h2>
<h3 id="界定问题">界定问题</h3>
<ul>
<li>设想问题产生的领域；</li>
<li>说明什么事情的发生打乱了该领域的稳定（困扰/困惑）；</li>
<li>确定非期望结果（现状，R1）；</li>
<li>确定期望结果（目标，R2）；</li>
<li>确定是否已经采取了解决问题的行动；</li>
<li>确定通过分析所要回答的疑问；</li>
</ul>
<h1 id="第9章-结构化分析问题">第9章 结构化分析问题</h1>
<ol>
<li>运用诊断框架呈现问题领域的详细结构，展示一个系统内的各个部分是如何相互影响的；
<ul>
<li>查找存在因果关系的活动；</li>
<li>对产生问题的可能原因进行分类；</li>
</ul>
</li>
<li>收集资料，以证明或排除结构中导致问题产生的部分；</li>
<li>使用逻辑树进行分析；
<ul>
<li>提出和检验解决方案；</li>
<li>揭示树状图中各思想的内在关系；</li>
</ul>
</li>
</ol>
<h2 id="关键概念-9">关键概念</h2>
<h3 id="结构化分析问题">结构化分析问题</h3>
<ul>
<li>界定问题；</li>
<li>使用诊断框架，呈现问题领域的详细结构；</li>
<li>假设产生问题的可能原因；</li>
<li>收集资料，以证明或排除所做假设；</li>
</ul>
<h1 id="第10章-在书面上呈现金字塔">第10章 在书面上呈现金字塔</h1>
<p>用多级标题、行首缩进、下划线和数字编号等方法，突出文章的整体结构。</p>
<ol>
<li>表现金字塔结构中主要组合之间的过渡；</li>
<li>表现金字塔结构中主要思想组之间的过渡；</li>
</ol>
<h1 id="第11章-在ppt演示文稿中呈现金字塔">第11章 在PPT演示文稿中呈现金字塔</h1>
<ol>
<li>制作文字幻灯片应尽量简明扼要；</li>
<li>制作图表幻灯片可以使传达的信息更简单易懂，在幻灯片的上部说明要传达的信息；</li>
<li>运用故事梗概，简要说明整体结构；</li>
<li>排练、排练，再排练！</li>
</ol>
<h1 id="第12章-在字里行间呈现金字塔">第12章 在字里行间呈现金字塔</h1>
<ol>
<li>画脑图（在大脑中画出图像或思维导图）；</li>
<li>把图像转化成文字；</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[F460 路由器端口映射]]></title>
        <id>https://winking324.github.io/post/f460-nat/</id>
        <link href="https://winking324.github.io/post/f460-nat/">
        </link>
        <updated>2019-10-18T02:17:47.000Z</updated>
        <summary type="html"><![CDATA[<p>家装电信，很多都采用中兴 F460 光猫（路由器），家里自己部署了一个服务器，想要映射到公网上，SSH 登陆上来。但是默认情况下，为了保证安全和防止黑客攻击，光猫上面是不允许将内部端口映射到公网上的。所以这里需要获取到光猫的超级管理员权限，进行端口映射的配置。</p>
]]></summary>
        <content type="html"><![CDATA[<p>家装电信，很多都采用中兴 F460 光猫（路由器），家里自己部署了一个服务器，想要映射到公网上，SSH 登陆上来。但是默认情况下，为了保证安全和防止黑客攻击，光猫上面是不允许将内部端口映射到公网上的。所以这里需要获取到光猫的超级管理员权限，进行端口映射的配置。</p>
<!-- more -->
<h1 id="1-获取密码">1 获取密码</h1>
<ol>
<li>链接电脑到光猫上，注意不要用第三个网口，这个网口是给 IPTV 预留的，分配的 IP 跟其他网口不一样；</li>
<li>打开浏览器，访问 <code>http://192.168.1.1/manager_dev_config_t.gch</code>，选择导出配置；</li>
<li>下载 <a href="http://aluigi.altervista.org/mytoolz.htm#Offzip">Offzip</a>，默认情况有 Windows 下的 offzip.exe，可以直接用，其他平台，执行 make 编译一下；</li>
<li>在命令行下，执行 <code>offzip.exe -a config.bin . 0</code> 来解压配置文件；</li>
<li>解压后会有多个文件，用文本编辑器打开各个文件，搜索 <code>telecomadmin</code>，对应的密码在相同位置；</li>
<li>打开浏览器，访问 <code>http://192.168.1.1</code>，输入对应的用户名密码，登陆成功；</li>
</ol>
<h1 id="2-配置端口映射">2 配置端口映射</h1>
<ol>
<li>超级管理员登陆；</li>
<li>点击菜单栏 <strong>应用</strong>；</li>
<li>选择 <strong>高级 NAT 配置</strong>；</li>
<li>选择 <strong>虚拟主机配置</strong>；</li>
<li>勾选 <strong>应用</strong>，打开虚拟主机配置；</li>
<li>名称填写自己的命名；</li>
<li>广域网主机起始 IP 地址，广域网主机结束 IP 地址：允许任意地址访问则不填写，否则填写指定的 IP 地址；</li>
<li>广域网连接：选择路由模式的连接，也就是当前电脑使用的联网模式，一般下拉菜单中只有一项，选择即可；</li>
<li>广域网起始端口，广域网结束端口：打开给外网访问的端口；</li>
<li>启用 MAC 映射：不勾选；</li>
<li>虚拟主机 IP 地址：局域网内部 IP 地址，例如说你内网服务器地址是 <code>192.168.1.5</code>，则填写这个地址；</li>
<li>虚拟主机起始端口，虚拟主机结束端口：局域网内部服务器允许对外访问的端口；</li>
</ol>
<h1 id="3-参考链接">3 参考链接</h1>
<ul>
<li><a href="http://www.myxzy.com/post-410.html">中兴光纤猫F460端口映射</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6c9aadc80102wvoz.html">破解电信路由器中兴F460</a></li>
<li><a href="https://pan.baidu.com/s/1d6ztZNOH6RvNVKx6I6xMGQ&amp;shfl=shareset">Offzip 下载</a> 提取码: f8ds</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 系统错误码]]></title>
        <id>https://winking324.github.io/post/linux-error-codes/</id>
        <link href="https://winking324.github.io/post/linux-error-codes/">
        </link>
        <updated>2019-10-10T06:26:56.000Z</updated>
        <summary type="html"><![CDATA[<p>When system requests fail, error code are returned. To understand the nature of the error these codes need to be interpreted.</p>
]]></summary>
        <content type="html"><![CDATA[<p>When system requests fail, error code are returned. To understand the nature of the error these codes need to be interpreted.</p>
<!-- more -->
<p>They are recorded in:-<br>
/usr/include/asm/errno.h</p>
<p>Here is a copy of that file as of Aug 2004 on RedHat 7.3</p>
<pre><code class="language-c++">#define EPERM            1      /* Operation not permitted */
#define ENOENT           2      /* No such file or directory */
#define ESRCH            3      /* No such process */
#define EINTR            4      /* Interrupted system call */
#define EIO              5      /* I/O error */
#define ENXIO            6      /* No such device or address */
#define E2BIG            7      /* Arg list too long */
#define ENOEXEC          8      /* Exec format error */
#define EBADF            9      /* Bad file number */
#define ECHILD          10      /* No child processes */
#define EAGAIN          11      /* Try again */
#define ENOMEM          12      /* Out of memory */
#define EACCES          13      /* Permission denied */
#define EFAULT          14      /* Bad address */
#define ENOTBLK         15      /* Block device required */
#define EBUSY           16      /* Device or resource busy */
#define EEXIST          17      /* File exists */
#define EXDEV           18      /* Cross-device link */
#define ENODEV          19      /* No such device */
#define ENOTDIR         20      /* Not a directory */
#define EISDIR          21      /* Is a directory */
#define EINVAL          22      /* Invalid argument */
#define ENFILE          23      /* File table overflow */
#define EMFILE          24      /* Too many open files */
#define ENOTTY          25      /* Not a typewriter */
#define ETXTBSY         26      /* Text file busy */
#define EFBIG           27      /* File too large */
#define ENOSPC          28      /* No space left on device */
#define ESPIPE          29      /* Illegal seek */
#define EROFS           30      /* Read-only file system */
#define EMLINK          31      /* Too many links */
#define EPIPE           32      /* Broken pipe */
#define EDOM            33      /* Math argument out of domain of func */
#define ERANGE          34      /* Math result not representable */
#define EDEADLK         35      /* Resource deadlock would occur */
#define ENAMETOOLONG    36      /* File name too long */
#define ENOLCK          37      /* No record locks available */
#define ENOSYS          38      /* Function not implemented */
#define ENOTEMPTY       39      /* Directory not empty */
#define ELOOP           40      /* Too many symbolic links encountered */
#define EWOULDBLOCK     EAGAIN  /* Operation would block */
#define ENOMSG          42      /* No message of desired type */
#define EIDRM           43      /* Identifier removed */
#define ECHRNG          44      /* Channel number out of range */
#define EL2NSYNC        45      /* Level 2 not synchronized */
#define EL3HLT          46      /* Level 3 halted */
#define EL3RST          47      /* Level 3 reset */
#define ELNRNG          48      /* Link number out of range */
#define EUNATCH         49      /* Protocol driver not attached */
#define ENOCSI          50      /* No CSI structure available */
#define EL2HLT          51      /* Level 2 halted */
#define EBADE           52      /* Invalid exchange */
#define EBADR           53      /* Invalid request descriptor */
#define EXFULL          54      /* Exchange full */
#define ENOANO          55      /* No anode */
#define EBADRQC         56      /* Invalid request code */
#define EBADSLT         57      /* Invalid slot */

#define EDEADLOCK       EDEADLK

#define EBFONT          59      /* Bad font file format */
#define ENOSTR          60      /* Device not a stream */
#define ENODATA         61      /* No data available */
#define ETIME           62      /* Timer expired */
#define ENOSR           63      /* Out of streams resources */
#define ENONET          64      /* Machine is not on the network */
#define ENOPKG          65      /* Package not installed */
#define EREMOTE         66      /* Object is remote */
#define ENOLINK         67      /* Link has been severed */
#define EADV            68      /* Advertise error */
#define ESRMNT          69      /* Srmount error */
#define ECOMM           70      /* Communication error on send */
#define EPROTO          71      /* Protocol error */
#define EMULTIHOP       72      /* Multihop attempted */
#define EDOTDOT         73      /* RFS specific error */
#define EBADMSG         74      /* Not a data message */
#define EOVERFLOW       75      /* Value too large for defined data type */
#define ENOTUNIQ        76      /* Name not unique on network */
#define EBADFD          77      /* File descriptor in bad state */
#define EREMCHG         78      /* Remote address changed */
#define ELIBACC         79      /* Can not access a needed shared library */
#define ELIBBAD         80      /* Accessing a corrupted shared library */
#define ELIBSCN         81      /* .lib section in a.out corrupted */
#define ELIBMAX         82      /* Attempting to link in too many shared libraries */
#define ELIBEXEC        83      /* Cannot exec a shared library directly */
#define EILSEQ          84      /* Illegal byte sequence */
#define ERESTART        85      /* Interrupted system call should be restarted */
#define ESTRPIPE        86      /* Streams pipe error */
#define EUSERS          87      /* Too many users */
#define ENOTSOCK        88      /* Socket operation on non-socket */
#define EDESTADDRREQ    89      /* Destination address required */
#define EMSGSIZE        90      /* Message too long */
#define EPROTOTYPE      91      /* Protocol wrong type for socket */
#define ENOPROTOOPT     92      /* Protocol not available */
#define EPROTONOSUPPORT 93      /* Protocol not supported */
#define ESOCKTNOSUPPORT 94      /* Socket type not supported */
#define EOPNOTSUPP      95      /* Operation not supported on transport endpoint */
#define EPFNOSUPPORT    96      /* Protocol family not supported */
#define EAFNOSUPPORT    97      /* Address family not supported by protocol */
#define EADDRINUSE      98      /* Address already in use */
#define EADDRNOTAVAIL   99      /* Cannot assign requested address */
#define ENETDOWN        100     /* Network is down */
#define ENETUNREACH     101     /* Network is unreachable */
#define ENETRESET       102     /* Network dropped connection because of reset */
#define ECONNABORTED    103     /* Software caused connection abort */
#define ECONNRESET      104     /* Connection reset by peer */
#define ENOBUFS         105     /* No buffer space available */
#define EISCONN         106     /* Transport endpoint is already connected */
#define ENOTCONN        107     /* Transport endpoint is not connected */
#define ESHUTDOWN       108     /* Cannot send after transport endpoint shutdown */
#define ETOOMANYREFS    109     /* Too many references: cannot splice */
#define ETIMEDOUT       110     /* Connection timed out */
#define ECONNREFUSED    111     /* Connection refused */
#define EHOSTDOWN       112     /* Host is down */
#define EHOSTUNREACH    113     /* No route to host */
#define EALREADY        114     /* Operation already in progress */
#define EINPROGRESS     115     /* Operation now in progress */
#define ESTALE          116     /* Stale NFS file handle */
#define EUCLEAN         117     /* Structure needs cleaning */
#define ENOTNAM         118     /* Not a XENIX named type file */
#define ENAVAIL         119     /* No XENIX semaphores available */
#define EISNAM          120     /* Is a named type file */
#define EREMOTEIO       121     /* Remote I/O error */
#define EDQUOT          122     /* Quota exceeded */

#define ENOMEDIUM       123     /* No medium found */
#define EMEDIUMTYPE     124     /* Wrong medium type */
</code></pre>
<p>Reference:</p>
<ul>
<li><a href="https://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html">Errors: Linux System Errors</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask 中使用定时任务]]></title>
        <id>https://winking324.github.io/post/flask-scheduler/</id>
        <link href="https://winking324.github.io/post/flask-scheduler/">
        </link>
        <updated>2019-09-25T05:29:30.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在使用 Flask 时，需要定期从远端服务器拉取 IP 数据，以提供相关 API 使用。所以使用了 apscheduler 这个定时任务框架来执行数据库读取以及本地数据更新等功能。</p>
<p>这里把踩过的一些坑整理一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在使用 Flask 时，需要定期从远端服务器拉取 IP 数据，以提供相关 API 使用。所以使用了 apscheduler 这个定时任务框架来执行数据库读取以及本地数据更新等功能。</p>
<p>这里把踩过的一些坑整理一下。</p>
<!-- more -->
<h1 id="1-如何设置定时任务">1 如何设置定时任务</h1>
<p>安装 APScheduler（Advanced Python Scheduler）：</p>
<pre><code class="language-shell">sudo pip3 install apscheduler
</code></pre>
<p>一个简单的定时任务如下：</p>
<pre><code class="language-python">import sys
import time
import atexit
from apscheduler.schedulers.background import BackgroundScheduler


def task():
    sys.stdout.write('\nrun task\n')
    sys.stdout.flush()


def main():
    scheduler = BackgroundScheduler()
    scheduler.add_job(func=task, trigger=&quot;interval&quot;, seconds=10)
    scheduler.start()
    atexit.register(lambda: scheduler.shutdown())

    for i in range(60):
        sys.stdout.write('.')
        sys.stdout.flush()
        time.sleep(1)


if __name__ == '__main__':
    main()
</code></pre>
<p>输出内容如下：</p>
<pre><code>..........
run task
..........
run task
..........
run task
..........
run task
..........
run task
..........
run task
</code></pre>
<p>这个简单的测试代码，说明了以下问题：</p>
<p>定时任务不是 start 时候立即执行，而是到期后执行第一次，所以对于读取数据库的任务，应该先调用触发一次，否则会有一段时间没有任何数据。</p>
<h1 id="2-使用-apscheduler-遇到的问题">2 使用 APScheduler 遇到的问题</h1>
<p>在 uwsgi + Flask 中使用 APScheduler 时，出现了以下问题：</p>
<p>当 uwsgi 设置 processes 个数不为 0 时，APScheduler 定期读取数据库更新的数据，只在父进程得到了更新，而在 worker 子进程中的数据没有更新。所以当用户请求到 worker 进程时，会获取最新的数据失败。</p>
<p>为了解决这个问题，尝试使用了几种方式：</p>
<ol>
<li>为每个 process 设置一个 APScheduler；</li>
<li>将父进程的更新同步到子进程；</li>
<li>使用 Flask-APScheduler；</li>
</ol>
<p>以上两个方式，最终均以失败告终，原因如下：</p>
<ol>
<li>APScheduler 官方文档中，有<a href="https://apscheduler.readthedocs.io/en/latest/faq.html#how-do-i-share-a-single-job-store-among-one-or-more-worker-processes">是否能够在多个 worker 间共享一个定期任务</a>，答案是否定的，并给出了相关的推荐做法；</li>
<li>多个进程间共享数据，有读写锁的问题，解决更加复杂；</li>
<li>Flask-APScheduler 仅仅是将 APScheduler 与 Flask 结合在一起，没有改变实际的实现方式，但是提供了更适合 Flask 的实践方式；</li>
</ol>
<h1 id="3-如何解决">3 如何解决</h1>
<p>解决这个问题，有两种方式：</p>
<ol>
<li>APScheduler 官方建议的，通过单独的一个服务来提供数据访问；</li>
<li>使用 redis 等数据库来达到数据同步；</li>
</ol>
<p>这里使用第二种方式，第 1 种方式需要自己来单独写服务，并且要保证服务的可用性，其实实现难度增大。并且使用 Flask-APScheduler 来提供统一的 APScheduler。</p>
<p>安装 Flask-APScheduler：</p>
<pre><code class="language-shell">sudo pip3 install Flask-APScheduler
</code></pre>
<p>实现逻辑如下：</p>
<pre><code class="language-python">import redis
import pymysql
import flask
import logging
from flask_apscheduler import APScheduler

app = flask.Flask(__name__)
app.logger.setLevel(logging.INFO)
app.config.from_mapping(
    JOBS=[{
        'id': 'reload_server',
        'func': 'app:reload_server',
        'args': (app.logger,),
        'trigger': 'interval',
        'seconds': 60
    }],
    SCHEDULER_API_ENABLED=True,
)

reload_scheduler = APScheduler()
reload_scheduler.init_app(app)
reload_scheduler.start()

redis_pool = redis.ConnectionPool(decode_responses=True)
redis_client = redis.Redis(connection_pool=redis_pool)


def reload_server(logger):
    logger.info('reload servers scheduler start')
    conn = pymysql.connect(host='127.0.0.1', port=3306,
                           user='root', passwd='root',
                           db='servers')
    exec_sql = 'SELECT `ip` FROM `servers`'
    cur = conn.cursor()
    cur.execute(exec_sql)
    for ip in cur:
        redis_client.set(ip, '', ex=60)
    conn.close()
    logger.info('reload servers scheduler stop')


if __name__ == '__main__':
    app.run()
</code></pre>
<p>在子进程中，则可以直接通过 redis 来读取数据。</p>
<h1 id="4-解决-redis-写效率">4 解决 redis 写效率</h1>
<p>测试过程中，发现 redis 从远端 mysql 获取到数据写到本地，速度是有点慢的，几千条数据需要花费几秒才能结束，所以针对写操作部分，进行了一定的优化。</p>
<p>使用 pipeline 的方式批量写入 redis：</p>
<pre><code class="language-python">def reload_server(logger):
    logger.info('reload servers scheduler start')
    conn = pymysql.connect(host='127.0.0.1', port=3306,
                           user='root', passwd='root',
                           db='servers')
    exec_sql = 'SELECT `ip` FROM `servers`'
    cur = conn.cursor()
    cur.execute(exec_sql)
    with redis_client.pipeline(transaction=False) as pipe:
        for ip in cur:
            pipe.set(ip, '', ex=60)
        pipe.execute()
    conn.close()
    logger.info('reload servers scheduler stop')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐讯 N1 盒子搭建 NAS]]></title>
        <id>https://winking324.github.io/post/n1-nas/</id>
        <link href="https://winking324.github.io/post/n1-nas/">
        </link>
        <updated>2019-08-08T05:51:46.000Z</updated>
        <summary type="html"><![CDATA[<p>T1 盒子安装红外模块，并刷完系统后，N1 盒子就放在家里落灰了。为了充分发挥它的作用，把它刷成了一个 NAS，来管理家里的存储设备。</p>
]]></summary>
        <content type="html"><![CDATA[<p>T1 盒子安装红外模块，并刷完系统后，N1 盒子就放在家里落灰了。为了充分发挥它的作用，把它刷成了一个 NAS，来管理家里的存储设备。</p>
<!-- more -->
<h1 id="1-刷机准备">1 刷机准备</h1>
<p>设备：</p>
<ol>
<li>N1 盒子一台；</li>
<li>U 盘一个；</li>
<li>显示器一台；</li>
<li>网线一根；</li>
<li>键盘一个；</li>
<li>网络环境；</li>
<li>电脑一台；</li>
</ol>
<p>工具：</p>
<ol>
<li>烧录工具：balenaEtcher；</li>
<li>终端工具：iTerm；</li>
<li>刷机系统：Armbian；</li>
</ol>
<p>打包地址：</p>
<p><a href="https://pan.baidu.com/s/1A97UHfFccERz06iJ6gioXA">百度网盘</a> 提取码: nb2k</p>
<h1 id="2-制作-armbian-系统盘">2 制作 Armbian 系统盘</h1>
<p>这里安装的系统是 Armbian，是一个轻量级的 Debian 系统和为 ARM 开发板专门发行并重新编译的 Debian 系统。</p>
<ol>
<li>将 <code>Armbian_5.77_Aml-s905_Debian_stretch_default_5.1.0-rc1_20190408以boot以加入dtd、extlinux、uEnv.ini.img.xz</code> 解压；</li>
<li>使用 balenaEtcher，将解压后的 <code>Armbian_5.77_Aml-s905_Debian_stretch_default_5.1.0-rc1_20190408以boot以加入dtd、extlinux、uEnv.ini.img</code> 烧录到 U 盘中；</li>
<li>Armbian 系统盘制作成功；</li>
</ol>
<h1 id="3-安装-armbian">3 安装 Armbian</h1>
<p>Mac 中，首先要安装 Android 工具包：</p>
<p><code>brew cask install android-platform-tools</code></p>
<ol>
<li>
<p>N1 接入网络并插入电源上电；</p>
</li>
<li>
<p>查看 N1 的 IP，这里假设为 <code>192.168.1.30</code>；</p>
</li>
<li>
<p>在终端工具中输入 <code>adb connect 192.168.1.30:5555</code> 连上 N1；</p>
</li>
<li>
<p>在终端工具中输入 <code>adb shell reboot update</code> 使 N1 重启进入刷机模式；</p>
</li>
<li>
<p>此时立即插入 U 盘到 HDMI 旁边的 USB 口；</p>
</li>
<li>
<p>等待刷机结束；</p>
</li>
<li>
<p>刷机结束后，会在控制台中显示 IP（假设仍为 <code>192.168.1.30</code>）和 Login 提示；</p>
</li>
<li>
<p>在终端工具中输入 <code>ssh root@192.168.1.30</code>，密码 1234 登陆到 Armbian 中；</p>
<figure data-type="image" tabindex="1"><img src="https://winking324.github.io/post-images/1565243675461.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>随便输入一个新的密码（因为后面会重新刷系统，这个密码只是临时用）；</p>
</li>
<li>
<p>提示创建用户，按 Ctrl-C 取消；</p>
</li>
</ol>
<p>Windows 中，可以使用之前 N1 刷机工具中的 <code>使N1进入线刷模式.zip</code> 中脚本来代替第 3、4 步的操作。</p>
<h1 id="4-安装-fastnas">4 安装 FastNas</h1>
<p>完成上面的 Armbian 系统的安装后，此时已经在 Armbian 系统中了，接下来需要将 FastNas 作者已经打好的系统包：<code>BACKUP-s9xxx-emmc.img.gz</code>，刷到 N1 上。</p>
<ol>
<li>
<p>打开一个新的终端，将文件传到 N1 上（Windows 中可以使用 WinSCP 等工具来上传文件）；</p>
<pre><code class="language-sh">scp -C -r BACKUP-s9xxx-emmc.img.gz root@192.168.1.30:~/
</code></pre>
</li>
<li>
<p>在已经登陆 N1 的终端中，将文件放到 <code>/ddbr</code> 路径下：</p>
<pre><code class="language-sh">mkdir -p /ddbr
mv BACKUP-s9xxx-emmc.img.gz /ddbr
</code></pre>
</li>
<li>
<p>执行 <code>ddbr</code> 命令进行 FastNas 安装：</p>
<figure data-type="image" tabindex="2"><img src="https://winking324.github.io/post-images/1565243690309.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>执行 <code>poweroff</code> 将 N1 盒子关机；</p>
</li>
<li>
<p>拔掉 U 盘，并重新上电开机；</p>
</li>
</ol>
<h1 id="5-网络设置">5 网络设置</h1>
<p>开机完成后，就已经进入了安装好 FastNas 的系统了，此时用户名为 root，密码为 media1984。</p>
<p>目前系统的内核有个问题，每次重启，MAC 地址会变化，所以如果使用 DHCP 方式获取 IP，会导致每次重启，N1 的 IP 都发生变化。</p>
<p>解决的办法如下：</p>
<ol>
<li>
<p>终端登陆 N1；</p>
</li>
<li>
<p>vi 打开编辑 <code>/etc/network/interfaces</code> 文件；</p>
</li>
<li>
<p>增加 <code>hwaddress ether 6a:c8:0b:05:88:52</code> 到 eth0（有线）配置中；</p>
<figure data-type="image" tabindex="3"><img src="https://winking324.github.io/post-images/1565243700384.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>输入 <code>reboot</code> 重启，可以看到 MAC 地址不会再发生变化；</p>
</li>
</ol>
<p>如果使用无线网络，使用 <code>armbian-config</code> 命令进行无线网络的配置。</p>
<h1 id="6-omv-设置">6 OMV 设置</h1>
<p>在电脑中，打开浏览器，输入 <code>http://192.168.1.30</code>，便可以进入 OpenMediaVault 系统（用户名：admin，密码：openmediavault）。</p>
<figure data-type="image" tabindex="4"><img src="https://winking324.github.io/post-images/1565243709299.jpg" alt="" loading="lazy"></figure>
<h1 id="7-参考链接">7 参考链接</h1>
<ul>
<li><a href="https://www.right.com.cn/forum/thread-847725-1-1.html">一键安装 FastNas V1.0.320190731 for Armbian Debian 5.77+OMV集成了可道云桌面</a></li>
<li><a href="https://www.right.com.cn/forum/thread-839364-1-1.html">N1盒子一键安装 FastNas V1.0.3 for Armbian Debian 5.77+OMV修复wifi 不可用</a></li>
<li><a href="https://www.right.com.cn/forum/thread-847730-1-1.html">Fastnas OMV挂载硬盘</a></li>
<li><a href="https://forum.armbian.com/topic/6354-does-nanopineos-gige-mac-address-randomly-change-from-time-to-time-after-rebooting/">Does NanoPiNEO's GigE Mac Address randomly change from time to time, after rebooting?</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐讯 T1 增加红外遥控]]></title>
        <id>https://winking324.github.io/post/t1-ir/</id>
        <link href="https://winking324.github.io/post/t1-ir/">
        </link>
        <updated>2019-08-01T06:08:42.000Z</updated>
        <summary type="html"><![CDATA[<p>在用树莓派获取斐讯 N1 盒子遥控器红外信号时，发现读取不到信息，查了一下，N1 盒子是通过蓝牙遥控器来控制的。虽然网上有各路神仙给 N1 盒子加红外模块，但是没看到有成功的。</p>
<p>但是看到斐讯 T1 盒子预留了红外模块，并且可以直接用红外遥控控制，所以又买了一个斐讯 T1 盒子，来达到红外控制的目的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在用树莓派获取斐讯 N1 盒子遥控器红外信号时，发现读取不到信息，查了一下，N1 盒子是通过蓝牙遥控器来控制的。虽然网上有各路神仙给 N1 盒子加红外模块，但是没看到有成功的。</p>
<p>但是看到斐讯 T1 盒子预留了红外模块，并且可以直接用红外遥控控制，所以又买了一个斐讯 T1 盒子，来达到红外控制的目的。</p>
<!-- more -->
<h1 id="1-刷机">1 刷机</h1>
<p>拿到盒子第一时间，不用说，先进行刷机，步骤和 N1 几乎完全一样，所以不再赘述，可以参考 N1 盒子来进行刷机。</p>
<p>这里唯一需要说明的是：</p>
<p>T1 在开机后，需要链接网络并进行账号注册，才能激活。需要跳过这一个步骤，进入到系统中，打开远程调试。</p>
<p>首先，扫描 T1 包装盒上面的二维码，下载<a href="https://phiclouds.phicomm.com/ota/service/app/downloadpage?appid=2017060031&amp;channel=1PTR">手机遥控器 App</a>：</p>
<figure data-type="image" tabindex="1"><img src="https://winking324.github.io/post-images/1565590380701.png" alt="" loading="lazy"></figure>
<p>这样用遥控器设置链接网络之后，就可以使用手机遥控 App 来操作 T1 盒子，此时按手机遥控 App 上的菜单按钮，就可以跳过注册，直接进入到盒子中了，并在设置中打开远程调试。</p>
<h1 id="2-安装红外">2 安装红外</h1>
<p>刷完机之后，关机，准备安装红外模块。</p>
<ol>
<li>
<p>撕开一点防滑条，将后盖拆下来；</p>
<figure data-type="image" tabindex="2"><img src="https://winking324.github.io/post-images/1565590418260.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>给红外模块开一个孔，这里我用乐高（伪，如图后面的小车）的一个透明块，挡在中间；</p>
<figure data-type="image" tabindex="3"><img src="https://winking324.github.io/post-images/1565590466267.jpeg" alt="" loading="lazy"></figure>
</li>
<li>
<p>开孔结束，把乐高透明块放在中间；</p>
<figure data-type="image" tabindex="4"><img src="https://winking324.github.io/post-images/1565590510352.jpeg" alt="" loading="lazy"></figure>
</li>
<li>
<p>拆下主板，将红外模块焊接在上面；</p>
<figure data-type="image" tabindex="5"><img src="https://winking324.github.io/post-images/1565590522079.jpeg" alt="" loading="lazy"></figure>
</li>
<li>
<p>用小米手机的红外遥控测试工作是否正常，这里我用开博尔这个牌子的遥控，可以完美遥控，距离四到五米都没啥问题；</p>
<figure data-type="image" tabindex="6"><img src="https://winking324.github.io/post-images/1565590542583.jpeg" alt="" loading="lazy"></figure>
</li>
<li>
<p>工作正常，将主板和盒子安装回去；</p>
<figure data-type="image" tabindex="7"><img src="https://winking324.github.io/post-images/1565590555823.jpeg" alt="" loading="lazy"></figure>
</li>
</ol>
<h1 id="3-参考链接">3 参考链接</h1>
<ul>
<li>
<p><a href="https://www.right.com.cn/forum/thread-321966-1-1.html">T1加装红外</a></p>
</li>
<li>
<p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=323450&amp;page=1">T1 加个红外接收头确实好用哦</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派报警器]]></title>
        <id>https://winking324.github.io/post/raspberry-alarm/</id>
        <link href="https://winking324.github.io/post/raspberry-alarm/">
        </link>
        <updated>2019-07-09T04:13:45.000Z</updated>
        <summary type="html"><![CDATA[<p>随着公司不断变大，作为报警监控用的“大电视”也越来越重要。但是更换位置之后，“大电视”被各种显示器遮挡，出现情况后，无法第一眼看到，所以做一个报警器来监控一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>随着公司不断变大，作为报警监控用的“大电视”也越来越重要。但是更换位置之后，“大电视”被各种显示器遮挡，出现情况后，无法第一眼看到，所以做一个报警器来监控一下。</p>
<!-- more -->
<h1 id="1-材料">1 材料</h1>
<p>准备需要的材料如下：</p>
<ul>
<li>
<p>树莓派一个；</p>
</li>
<li>
<p>SD 卡一张；</p>
</li>
<li>
<p>报警器一个；</p>
</li>
<li>
<p>电源线（带插头）一根；</p>
</li>
<li>
<p>继电器一个；</p>
</li>
<li>
<p>杜邦线数根；</p>
</li>
<li>
<p>USB 数据线一根；</p>
</li>
<li>
<p>HDMI 线一根；</p>
</li>
<li>
<p>键盘一个；</p>
</li>
<li>
<p>显示器一台；</p>
</li>
</ul>
<p>主要设备如下：</p>
<figure data-type="image" tabindex="1"><img src="https://winking324.github.io/post-images/1562645732607.png" alt="" loading="lazy"></figure>
<h1 id="2-安装环境">2 安装环境</h1>
<h2 id="21-烧录系统">2.1 烧录系统</h2>
<p>准备好一个<a href="https://www.raspberrypi.org/downloads/">树莓派镜像</a>，这里使用的是 <a href="https://downloads.raspberrypi.org/raspbian_lite_latest.torrent">Raspbian Buster Lite</a>。</p>
<p>另外使用 <a href="https://www.balena.io/etcher/">balenaEtcher</a> 烧录软件，进行镜像的烧录，如果有其他的软件，可以根据需要自行进行系统的烧录。</p>
<ol>
<li>
<p>选择镜像，并选择对应的 SD 卡，点击烧录；</p>
<figure data-type="image" tabindex="2"><img src="https://winking324.github.io/post-images/1562645746399.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>烧录成功；</p>
<figure data-type="image" tabindex="3"><img src="https://winking324.github.io/post-images/1562645756401.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h2 id="22-初始化环境">2.2 初始化环境</h2>
<p>将烧录好的 SD 卡，插到树莓派上，并给树莓派链接显示器、键盘、网线（非必须），之后插入 USB 上电。</p>
<p>经过一次自动重启后，树莓派会成功载入系统，并跳出登陆界面。输入用户名 pi 和默认密码 raspberry 后，进入到系统中。</p>
<p>设置 SSH 及 WiFi（如有必要设置键盘布局）等：</p>
<pre><code class="language-sh"># 进入设置
sudo raspi-config
</code></pre>
<p>更新 apt 源及系统：</p>
<pre><code class="language-sh"># apt source
sudo sed -i 's#://raspbian.raspberrypi.org#s://mirrors.ustc.edu.cn/raspbian#g' /etc/apt/sources.list
sudo sed -i 's#://archive.raspberrypi.org/debian#s://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian#g' /etc/apt/sources.list.d/raspi.list

# update and upgrade
sudo apt-get update
sudo apt-get upgrade -y
</code></pre>
<p>安装后面需要的模块及软件：</p>
<pre><code class="language-sh">sudo apt-get install -y nginx python3-pip python3-rpi.gpio
sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple flask uwsgi
</code></pre>
<h1 id="3-调试继电器">3 调试继电器</h1>
<p>由于报警灯默认是用 220V 的交流电，上来直接测试，会有比较大的安全风险，所以我们这里先用 LED 灯来进行测试，如果成功，再将 LED 灯替换为报警灯。</p>
<h2 id="31-继电器">3.1 继电器</h2>
<p>继电器很简单，一端接树莓派进行开关控制，另外一端接设备，如图：</p>
<figure data-type="image" tabindex="4"><img src="https://winking324.github.io/post-images/1562645785924.png" alt="" loading="lazy"></figure>
<p>这个继电器对内是直接用树莓派的 5V 电压，对外可以接：</p>
<ul>
<li>10A 250V 交流电</li>
<li>10A 125V 交流电</li>
<li>10A 30V 直流电</li>
<li>10A 28V 的直流电</li>
</ul>
<p>从上图可以看到，对外三个接口对应的开关状态，中间接火线，如果希望默认开关长闭状态，对应左边；如果希望默认开关长开状态，对应右边。我们这里希望报警器默认是关闭的，所以接入右边。</p>
<h2 id="32-led">3.2 LED</h2>
<p>LED 灯就比较简单了，直接两个阵脚，一个接入 GPIO，一个接入负极。</p>
<p>最后整体如图：</p>
<figure data-type="image" tabindex="5"><img src="https://winking324.github.io/post-images/1562645777502.png" alt="" loading="lazy"></figure>
<h2 id="32-调试">3.2 调试</h2>
<p>这里用 Python3 简单调试一下，代码如下：</p>
<pre><code class="language-python">import RPi.GPIO as GPIO
import time

# GPIO 17
led_pin = 11
# GPIO 18
relay_pin = 12


def setup():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(led_pin, GPIO.OUT)
    GPIO.setup(relay_pin, GPIO.OUT)

    # led on
    GPIO.output(led_pin, GPIO.HIGH)
    # relay off
    GPIO.output(relay_pin, GPIO.LOW)


def loop():
    relay = 0
    while True:
        GPIO.output(relay_pin, GPIO.HIGH if relay == 1 else GPIO.LOW)
        time.sleep(2)
        relay = int(input('0: Close, 1: Open'))


def destroy():
    GPIO.output(led_pin, GPIO.LOW)
    GPIO.output(relay_pin, GPIO.LOW)

    # Release resource
    GPIO.cleanup()


if __name__ == '__main__':
    setup()
    try:
        loop()
    except KeyboardInterrupt:
        # When 'Ctrl+C' is pressed,
        # the child program destroy() will be  executed.
        destroy()
</code></pre>
<p>逻辑很简单，当输入 1 时，继电器进入闭合状态，LED 会亮起来；当输入 0 时，继电器进入打开状态，LED 会关闭。</p>
<h1 id="4-调试报警灯">4 调试报警灯</h1>
<p>链接报警灯：</p>
<figure data-type="image" tabindex="6"><img src="https://winking324.github.io/post-images/1562645797278.png" alt="" loading="lazy"></figure>
<p>当然这是初步连接，用于给大家展示接口，有需要尝试的小伙伴，一定要用电工胶布，把裸露的电线包好，避免出现意外事故。</p>
<p>连接好之后，插入电源，用下面的代码进行测试。</p>
<pre><code class="language-python">import RPi.GPIO as GPIO
import time

# GPIO 18
relay_pin = 12


def setup():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(relay_pin, GPIO.OUT)
    GPIO.output(relay_pin, GPIO.LOW)


def loop():
    relay = 0
    while True:
        GPIO.output(relay_pin, GPIO.HIGH if relay == 1 else GPIO.LOW)
        time.sleep(2)
        relay = int(input('0: Close, 1: Open'))


def destroy():
    GPIO.output(relay_pin, GPIO.LOW)
    GPIO.cleanup()


if __name__ == '__main__':
    setup()
    try:
        loop()
    except KeyboardInterrupt:
        destroy()
</code></pre>
<p>报警灯可以正常的进行工作：</p>
<figure data-type="image" tabindex="7"><img src="https://winking324.github.io/post-images/1562645805640.gif" alt="" loading="lazy"></figure>
<h1 id="5-报警服务">5 报警服务</h1>
<p>这里用 Nginx + uwsgi + flask 来搭建一个 web 服务，当有报警请求过来时，触发打开报警灯。</p>
<h2 id="51-nginx-配置">5.1 Nginx 配置</h2>
<p>在树莓派中执行以下命令：</p>
<pre><code class="language-sh">cd /etc/nginx/sites-enabled/
sudo mv default marmot.conf
</code></pre>
<p>修改 marmot.conf 文件，内容如下：</p>
<pre><code class="language-nginx">server {
        listen 80;
        listen [::]:80;

        location / {
                include        uwsgi_params;
                uwsgi_pass     127.0.0.1:5051;
                uwsgi_param UWSGI_CHDIR /home/pi/marmot;
                uwsgi_param UWSGI_SCRIPT app:app;
        }
}
</code></pre>
<p>重新加载 nginx 配置文件：</p>
<pre><code class="language-sh">sudo service nginx reload
</code></pre>
<h2 id="52-uwsgi-配置">5.2 uwsgi 配置</h2>
<p>创建 uwsgi 配置文件 <code>uwsgi_config.ini</code>：</p>
<pre><code class="language-ini">[uwsgi]
socket = 127.0.0.1:5051
master = true
project = /home/pi/marmot
pythonpath = %(project)
module = app
wsgi-file = %(project)/app.py
callable = app
processes = 1
threads = 1
daemonize = %(project)/server.log
stats = %(project)/uwsgi/uwsgi.status
pidfile = %(project)/uwsgi/uwsgi.pid
</code></pre>
<h2 id="53-报警服务">5.3 报警服务</h2>
<p>简单写一个 web 服务，有请求时，触发报警：</p>
<pre><code class="language-python">import time
import logging
import RPi.GPIO as GPIO
from flask import Flask


app = Flask(__name__, instance_relative_config=True)
app.logger.setLevel(logging.INFO)

# GPIO 18
relay_pin = 12


def setup_marmot():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(relay_pin, GPIO.OUT)
    GPIO.output(relay_pin, GPIO.LOW)

    
def destroy_marmot():
    GPIO.output(relay_pin, GPIO.LOW)
    GPIO.cleanup()
    
    
@app.route('/')
def marmot():
    app.logger.info('what does the marmot say')
    setup_marmot()
    GPIO.output(relay_pin, GPIO.HIGH)
  	time.sleep(5)
    destroy_marmot()
    return 'Ahhhhhhhhhhhhhhh...'


if __name__ == '__main__':
    app.run()
</code></pre>
<p>启动服务：</p>
<pre><code class="language-sh">uwsgi --ini uwsgi_config.ini
</code></pre>
<p>在浏览器里面，输入树莓派的地址，发送请求测试，报警成功。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派红外模块对接]]></title>
        <id>https://winking324.github.io/post/raspberry-lirc/</id>
        <link href="https://winking324.github.io/post/raspberry-lirc/">
        </link>
        <updated>2019-07-04T04:56:38.000Z</updated>
        <summary type="html"><![CDATA[<p>随着家里的电器越来越多，遥控器也越来越多，例如投影仪遥控、电视盒子遥控、HDMI 分线器遥控、NAS 存储遥控、音响遥控、电灯遥控、小夜灯遥控、空调遥控等等。所以当我想看一部电影时，需要用先打开投影仪，再打开电视盒子，然后打开 NAS 存储，接着打开 HDMI 分线器，跟着打开音响，甚至还要关上电灯。</p>
]]></summary>
        <content type="html"><![CDATA[<p>随着家里的电器越来越多，遥控器也越来越多，例如投影仪遥控、电视盒子遥控、HDMI 分线器遥控、NAS 存储遥控、音响遥控、电灯遥控、小夜灯遥控、空调遥控等等。所以当我想看一部电影时，需要用先打开投影仪，再打开电视盒子，然后打开 NAS 存储，接着打开 HDMI 分线器，跟着打开音响，甚至还要关上电灯。</p>
<!-- more -->
<p>一系列的操作简直烦不胜烦，然后就想是不是可以用一个遥控器，控制所有电器呢？毕竟大部分电器的遥控器，无非也就是按一下开关键而已。</p>
<p>所以计划用树莓派和红外模块来进行电器的整体控制。</p>
<h1 id="1-红外模块">1 红外模块</h1>
<p>树莓派已经有了，那现在缺的是一个红外模块，所以先淘宝和各种论坛搜了一下，找到了这个不错的红外模块。</p>
<figure data-type="image" tabindex="1"><img src="https://winking324.github.io/post-images/1562216778147.png" alt="" loading="lazy"></figure>
<p>这个模块有接收和发送两个部分，另外让淘宝老板多加了一个红外发射器 D2，到货时，老板已经贴心的帮忙焊了上去。</p>
<p>但是我的树莓派加了一个合金的外壳，并且有散热风扇，如下：</p>
<figure data-type="image" tabindex="2"><img src="https://winking324.github.io/post-images/1562216791197.png" alt="" loading="lazy"></figure>
<p>另外看了一下树莓派阵脚的定义，如下（这个是扩展模块，每一列都是一样的，所以只看一列就可以了）：</p>
<figure data-type="image" tabindex="3"><img src="https://winking324.github.io/post-images/1562216808667.png" alt="" loading="lazy"></figure>
<p>就会有两个问题：</p>
<ol>
<li>插上这个模块，需要把外壳移除；</li>
<li>这个模块占用了 5v 正极，导致散热风扇也没法用；</li>
</ol>
<p>所以大概看了一下红外模块的阵脚，发现其实它只用了以下几个阵脚：</p>
<ol>
<li>3.3v：正极；</li>
<li>GND：负极；</li>
<li>P17：红外发射；</li>
<li>P18：红外接收；</li>
<li>P27：开关1；</li>
<li>P22：开关2；</li>
</ol>
<p>所以用排线把这几个阵脚对应连起来就可以了，这样好处就是解决了上面的两个问题，但是缺点是加了排线，导致整体看起来比较乱，不够精简。不过后面可以放到自制的盒子里面，把这些遮挡起来，就可以解决了。</p>
<p>具体的阵脚链接，大家可以参考：</p>
<figure data-type="image" tabindex="4"><img src="https://winking324.github.io/post-images/1562216822476.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://winking324.github.io/post-images/1562216832768.png" alt="" loading="lazy"></figure>
<h1 id="2-测试模块">2 测试模块</h1>
<p>接线结束后，首先要测试一下模块是不是工作正常，如果整体工作正常，才能细化各部分逻辑。否则开发了半天，发现模块工作不正常，各种事情都要返工，就得不偿失了。</p>
<p>测试过程中，查了不少资料，也绕了不少弯路，主要问题总结如下：</p>
<ol>
<li>
<p>很多资料比较老，在内核 4.19.x 以上版本，都不能跟资料介绍的那样正常工作；</p>
<p>由于在内核 4.19.x 以上版本，移除了对 <code>dtoverlay=lirc-rpi</code> 的支持，改为 <code>dtoverlay=gpio-ir</code> 以及 <code>dtoverlay=gpio-ir-tx</code> 方式。所以如果查看资料中，是以 <code>lirc-rpi</code> 方式集成的，那就可以无视这个资料了；</p>
</li>
<li>
<p>lirc 这个模块的最新版本，配置也跟之前老版本的不同，不需要 <code>/etc/lirc/hardware.conf</code> 等配置文件；</p>
</li>
</ol>
<p>踩了好多坑，正确的姿势应该按照下面的步骤执行。</p>
<h2 id="21-确认内核版本">2.1 确认内核版本</h2>
<pre><code class="language-sh">uname -a
# 输出如下
# Linux raspberrypi 4.14.79-v7+ #1159 SMP Sun Nov 4 17:50:20 GMT 2018 armv7l GNU/Linux
</code></pre>
<p>对于输出内容的说明如下：</p>
<ul>
<li><code>Linux</code>：kernel name</li>
<li><code>raspberrypi</code>：network node hostname</li>
<li><code>4.14.79-v7+</code>：kernel release</li>
<li><code>#1159 SMP Sun Nov 4 17:50:20 GMT 2018</code>：kernel version</li>
<li><code>armv7l</code>：machine hardware name</li>
<li><code>GNU/Linux</code>：operating system</li>
</ul>
<p>可以看到当前的内核版本为 <code>4.14.79-v7+</code>。打开 <code>/boot/overlays/README</code> 并搜索 <code>lirc-rpi</code> 后，发现：</p>
<pre><code>Name:   lirc-rpi
Info:   This overlay has been deprecated and removed - see gpio-ir
Load:   &lt;Deprecated&gt;
</code></pre>
<p><code>lirc-rpi</code> 已经被标记成已废弃，并且<mark>已经移除</mark>，使用 <code>gpio-ir</code> 来替换。</p>
<p>所以首先要先确认自己的内核版本，并查看 <code>/boot/overlays/README</code>，确定 <code>lirc-rpi</code> 在自己的系统上是否可用（如果可用的话，可以直接找相关的集成文档，这部分有很多资料，这里就不多说了）。</p>
<h2 id="22-安装-lirc">2.2 安装 lirc</h2>
<p><a href="http://www.lirc.org/">lirc</a> 是 Linux 下，提供红外信号编解码，以及收发能力的一个模块。有了这个模块，我们不需要去实现红外信号处理等很复杂的逻辑。</p>
<p>安装：</p>
<pre><code class="language-sh">sudo apt-get install -y lirc
</code></pre>
<h2 id="23-配置-gpio">2.3 配置 gpio</h2>
<p>首先，配置 gpio，让系统知道红外模块是通过哪几个引脚来进行控制的。</p>
<p>在前面，我们在接线的时候，提到：</p>
<ul>
<li>
<p>P17：红外发射；</p>
</li>
<li>
<p>P18：红外接收；</p>
</li>
</ul>
<p>所以需要将这两个引脚配置到系统中。</p>
<pre><code class="language-sh"># 打开编辑 /boot/config.txt 文件
sudo vi /boot/config.txt

# 找到 dtoverlay 的声明位置，增加以下声明
dtoverlay=gpio-ir,gpio_pin=18
dtoverlay=gpio-ir-tx,gpio_pin=17

# 保存退出，并重启树莓派
sudo reboot
</code></pre>
<p>重启后，进入系统，执行 <code>ls /dev</code> 可以看到 <code>lirc0</code> 和 <code>lirc1</code> 这两个设备，说明配置成功。</p>
<h2 id="24-测试红外接收">2.4 测试红外接收</h2>
<p>停掉 lircd 服务：</p>
<pre><code class="language-sh">sudo systemctl stop lircd.socket
sudo systemctl stop lircd.service
</code></pre>
<p>读取红外模块接收的内容：</p>
<pre><code class="language-sh">mode2 --driver default --device /dev/lirc1
</code></pre>
<p>进入红外读取状态：</p>
<pre><code class="language-sh">Using driver devinput on device /dev/lirc1
Trying device: /dev/lirc1
Using device: /dev/lirc1
</code></pre>
<p>然后用遥控器随便按一个键，会出现以下内容：</p>
<pre><code class="language-sh">space 16777215
pulse 95
space 182
pulse 1616
space 221
pulse 766
space 76
pulse 443
space 277
pulse 149
space 387
pulse 908
space 168
pulse 94
space 348
pulse 741
space 80
pulse 738
space 485
pulse 82
space 152
pulse 344
space 74
pulse 132
space 4898
pulse 515
space 641
pulse 443
space 748
pulse 94
space 170
pulse 89
space 1894
pulse 383
space 647
pulse 86
space 256
pulse 179
space 797
pulse 89
space 944
pulse 198
space 1061
pulse 314
space 1883
pulse 257
space 1861
pulse 116
space 224
pulse 84
space 1884
pulse 454
space 1698
pulse 87
space 175
pulse 120
space 1932
pulse 476
space 1778
pulse 496
space 1802
pulse 96
space 2153
pulse 355
space 1953
pulse 375
space 591
pulse 545
space 1726
pulse 334
space 933
pulse 386
space 643
pulse 493
space 643
pulse 386
space 2091
pulse 239
space 641
pulse 340
space 798
pulse 486
space 1779
pulse 496
space 747
pulse 90
space 2209
pulse 308
space 1805
pulse 84
space 115
pulse 241
space 1751
pulse 87
space 175
pulse 174
space 719
pulse 471
space 1857
pulse 92
pulse 21981
space 61979
space 40451
pulse 89
space 143
pulse 96
space 221
pulse 904
space 121
pulse 1057
space 84
pulse 2610
space 303
pulse 1550
space 83
pulse 95
space 188
pulse 1004
space 2820
pulse 381
pulse 19764
</code></pre>
<h2 id="25-测试红外发送">2.5 测试红外发送</h2>
<p>waiting for update</p>
<h1 id="3-参考链接">3 参考链接</h1>
<ul>
<li>
<p><a href="http://www.lirc.org/">LIRC</a></p>
</li>
<li>
<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=235256">Using LIRC with kernel 4.19.X and gpio-ir</a></p>
</li>
<li>
<p><a href="https://superuser.com/questions/1441396/rpi-3b-lirc-wont-setup-device-could-not-get-file-information-for-dev-lirc0">RPi 3B — LIRC won't setup device: could not get file information for /dev/lirc0</a></p>
</li>
<li>
<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=235918">lirc on Raspberry Pi Zero W with gpio-ir</a></p>
</li>
<li>
<p><a href="https://www.sunfounder.com/learn/sensor-kit-v2-0-for-raspberry-pi-b-plus/lesson-23-ir-remote-control-sensor-kit-v2-0-for-b-plus.html">Lesson 23 IR Remote Control</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx + uWSGI + Flask + WebSocket]]></title>
        <id>https://winking324.github.io/post/nginx-uwsgi-flask-websocket/</id>
        <link href="https://winking324.github.io/post/nginx-uwsgi-flask-websocket/">
        </link>
        <updated>2019-07-02T11:31:38.000Z</updated>
        <summary type="html"><![CDATA[<p>一个应用服务器，想要提供短链接和长连接两类服务类型时，一般短链接用 HTTP 方式，而长链接采用 WebSocket 方式。</p>
<p>所以用 Flask 如何提供这两种服务类型呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个应用服务器，想要提供短链接和长连接两类服务类型时，一般短链接用 HTTP 方式，而长链接采用 WebSocket 方式。</p>
<p>所以用 Flask 如何提供这两种服务类型呢？</p>
<!-- more -->
<p>这里使用 <a href="https://github.com/zeekay/flask-uwsgi-websocket">Flask-uWSGI-WebSocket</a> 这个插件，采用 Nginx + uWSGI + Flask + WebSocket 的方式来提供 HTTP 和 WebSocket 两种服务类型。</p>
<ol>
<li>
<p>安装 Flask-uWSGI-WebSocket 插件；</p>
<pre><code class="language-sh">sudo pip3 install Flask-uWSGI-WebSocket
</code></pre>
</li>
<li>
<p>修改 uwsgi 配置文件：</p>
<pre><code class="language-ini">[uwsgi]
socket = 127.0.0.1:5051
master = true
project = /data/projects/flaskr/
pythonpath = %(project)
module = app
wsgi-file = %(project)/app.py
callable = app
processes = 1
threads = 1
daemonize = %(project)/server.log
stats = %(project)/uwsgi/uwsgi.status
pidfile = %(project)/uwsgi/uwsgi.pid

# 增加
gevent = 100
</code></pre>
</li>
<li>
<p>修改 Flask 相关逻辑；</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
__author__ = &quot;winking324@gmail.com&quot;
__copyright__ = &quot;Copyright (c) 2019 winking.io, Inc.&quot;


from flask import Flask
from flask_uwsgi_websocket import GeventWebSocket


app = Flask(__name__, instance_relative_config=True)
websocket = GeventWebSocket(app)


@app.route('/')
def hello_world():
    return 'Hello World!'

  
@websocket.route('/echo')
def echo(ws):
    while True:
        msg = ws.receive()
        if msg is not None:
            if msg:
                ws.send(msg)
        else:
            return

              
if __name__ == '__main__':
    app.run()
</code></pre>
</li>
<li>
<p>重启 uwsgi；</p>
<pre><code class="language-sh">uwsgi --reload /data/projects/flaskr/uwsgi/uwsgi.pid
</code></pre>
</li>
<li>
<p>测试 WebSocket 服务；</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx + uWSGI + Flask]]></title>
        <id>https://winking324.github.io/post/nginx-uwsgi-flask/</id>
        <link href="https://winking324.github.io/post/nginx-uwsgi-flask/">
        </link>
        <updated>2019-07-02T11:00:29.000Z</updated>
        <summary type="html"><![CDATA[<p>上次说到了 Flask，接触到 uWSGI。在实际生产环境，一般采用 Nginx + uWSGI + Flask 的组合方式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上次说到了 Flask，接触到 uWSGI。在实际生产环境，一般采用 Nginx + uWSGI + Flask 的组合方式。</p>
<!-- more -->
<ul>
<li>Nginx 负责提供对外的 Web 服务；</li>
<li>uWSGI 充当中间件，桥接对外的 Web 服务和实际的应用服务；</li>
<li>Flask 提供应用服务，完成业务逻辑；</li>
</ul>
<h1 id="1-nginx-配置">1 Nginx 配置</h1>
<p>在这里，使用 Nginx 的主要目的如下：</p>
<ol>
<li>安全。客户端对 Web 服务器的访问需要先经过 Nginx。这样可以防止外部程序直接对应用服务器的恶意攻击；</li>
<li>负载均衡。在有多个应用服务器的情况下，Nginx 可以根据应用服务器的负载情况，动态地把请求交给不同的应用服务器来处理；</li>
<li>提升 IO 性能。一个 HTTP 请求的数据，从客户端传输给服务器，是需要时间的，例如 N 秒，如果直接传给应用服务器，应用服务器就需要让一个进程（或线程）阻塞 N 秒，进行 IO 操作，这样会降低应用服务器的性能。如果先让 Nginx 接收完整的 HTTP 请求，再把请求发给应用服务器，就能提升应用服务器的性能。还有一些静态文件的请求，可以直接交给 Nginx 来处理，不需要经过应用服务器，降低了应用服务器的 QPS。</li>
</ol>
<p>但是默认情况下，Nginx 不具备 WSGI 规范的能力，需要通过 <a href="http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html">ngx_http_uwsgi_module</a> 模块进行扩展，这个模块默认已经集成在 Nginx，所以不需要重新编译 Nginx。</p>
<pre><code class="language-sh"># 修改 Nginx 配置
sudo vi /etc/nginx/sites-enabled/default

# 修改 location 部分
location / {
	include        uwsgi_params;
	uwsgi_pass     127.0.0.1:5051;
	uwsgi_param UWSGI_CHDIR  /data/projects/flaskr;
	uwsgi_param UWSGI_SCRIPT app:app;
}

# 保存配置，并重新加载
sudo systemctl reload nginx
</code></pre>
<h1 id="2-uwsgi-配置">2 uWSGI 配置</h1>
<p>Python 默认情况下，没有 uWSGI，所以需要手动安装一下：</p>
<pre><code class="language-sh">sudo pip3 install uwsgi
</code></pre>
<p>之后，在 Flask 项目中，创建 uWSGI 的配置文件 <code>/data/projects/flaskr/uwsgi_config.ini</code>，并配置如下：</p>
<pre><code class="language-ini">[uwsgi]
socket = 127.0.0.1:5051
master = true
project = /data/projects/flaskr/
pythonpath = %(project)
module = app
wsgi-file = %(project)/app.py
callable = app
processes = 1
threads = 1
daemonize = %(project)/server.log
stats = %(project)/uwsgi/uwsgi.status
pidfile = %(project)/uwsgi/uwsgi.pid
</code></pre>
<h1 id="3-flask-应用">3 Flask 应用</h1>
<p>编写一个简单的 Flask 应用，先用来测试。创建 <code>/data/projects/flaskr/app.py</code> 文件，并输入：</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
__author__ = &quot;winking324@gmail.com&quot;
__copyright__ = &quot;Copyright (c) 2019 winking.io, Inc.&quot;


from flask import Flask


app = Flask(__name__, instance_relative_config=True)


@app.route('/')
def hello_world():
    return 'Hello World!'


if __name__ == '__main__':
    app.run()
</code></pre>
<p>使用 uwsgi 命令启动 Flask 应用服务：</p>
<pre><code class="language-sh">uwsgi --ini /data/projects/flaskr/uwsgi_config.ini
</code></pre>
<p>如果需要重启 uwsgi，使用：</p>
<pre><code class="language-sh">uwsgi --reload /data/projects/flaskr/uwsgi/uwsgi.pid
</code></pre>
<p>如果需要停止服务，使用：</p>
<pre><code class="language-sh">uwsgi --stop /data/projects/flaskr/uwsgi/uwsgi.pid
</code></pre>
<h1 id="4-请求测试">4 请求测试</h1>
<p>在浏览器中，访问对应 Nginx 的地址，会在浏览器中显示 <code>Hello world!</code>。</p>
<h1 id="5-参考链接">5 参考链接</h1>
<ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html">ngx_http_uwsgi_module 说明文档</a></li>
<li><a href="https://www.cnblogs.com/cuchadanfan/p/6237584.html">ngx_http_uwsgi_module 中文文档</a></li>
</ul>
]]></content>
    </entry>
</feed>