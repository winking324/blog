<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://winking324.github.io</id>
    <title>Winking</title>
    <updated>2019-07-09T04:18:26.496Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://winking324.github.io"/>
    <link rel="self" href="https://winking324.github.io/atom.xml"/>
    <subtitle>还愣着干啥！点赞啊！</subtitle>
    <logo>https://winking324.github.io/images/avatar.png</logo>
    <icon>https://winking324.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Winking</rights>
    <entry>
        <title type="html"><![CDATA[树莓派报警器]]></title>
        <id>https://winking324.github.io/post/raspberry-alarm</id>
        <link href="https://winking324.github.io/post/raspberry-alarm">
        </link>
        <updated>2019-07-09T04:13:45.000Z</updated>
        <summary type="html"><![CDATA[<p>随着公司不断变大，作为报警监控用的“大电视”也越来越重要。但是更换位置之后，“大电视”被各种显示器遮挡，出现情况后，无法第一眼看到，所以做一个报警器来监控一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>随着公司不断变大，作为报警监控用的“大电视”也越来越重要。但是更换位置之后，“大电视”被各种显示器遮挡，出现情况后，无法第一眼看到，所以做一个报警器来监控一下。</p>
<!-- more -->
<h1 id="1-材料">1 材料</h1>
<p>准备需要的材料如下：</p>
<ul>
<li>
<p>树莓派一个；</p>
</li>
<li>
<p>SD 卡一张；</p>
</li>
<li>
<p>报警器一个；</p>
</li>
<li>
<p>电源线（带插头）一根；</p>
</li>
<li>
<p>继电器一个；</p>
</li>
<li>
<p>杜邦线数根；</p>
</li>
<li>
<p>USB 数据线一根；</p>
</li>
<li>
<p>HDMI 线一根；</p>
</li>
<li>
<p>键盘一个；</p>
</li>
<li>
<p>显示器一台；</p>
</li>
</ul>
<p>主要设备如下：</p>
<p><img src="https://winking324.github.io/post-images/1562645732607.png" alt=""></p>
<h1 id="2-安装环境">2 安装环境</h1>
<h2 id="21-烧录系统">2.1 烧录系统</h2>
<p>准备好一个<a href="https://www.raspberrypi.org/downloads/">树莓派镜像</a>，这里使用的是 <a href="https://downloads.raspberrypi.org/raspbian_lite_latest.torrent">Raspbian Buster Lite</a>。</p>
<p>另外使用 <a href="https://www.balena.io/etcher/">balenaEtcher</a> 烧录软件，进行镜像的烧录，如果有其他的软件，可以根据需要自行进行系统的烧录。</p>
<ol>
<li>
<p>选择镜像，并选择对应的 SD 卡，点击烧录；</p>
<p><img src="https://winking324.github.io/post-images/1562645746399.png" alt=""></p>
</li>
<li>
<p>烧录成功；</p>
<p><img src="https://winking324.github.io/post-images/1562645756401.png" alt=""></p>
</li>
</ol>
<h2 id="22-初始化环境">2.2 初始化环境</h2>
<p>将烧录好的 SD 卡，插到树莓派上，并给树莓派链接显示器、键盘、网线（非必须），之后插入 USB 上电。</p>
<p>经过一次自动重启后，树莓派会成功载入系统，并跳出登陆界面。输入用户名 pi 和默认密码 raspberry 后，进入到系统中。</p>
<p>设置 SSH 及 WiFi（如有必要设置键盘布局）等：</p>
<pre><code class="language-sh"># 进入设置
sudo raspi-config
</code></pre>
<p>更新 apt 源及系统：</p>
<pre><code class="language-sh"># apt source
sudo sed -i 's#://raspbian.raspberrypi.org#s://mirrors.ustc.edu.cn/raspbian#g' /etc/apt/sources.list
sudo sed -i 's#://archive.raspberrypi.org/debian#s://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian#g' /etc/apt/sources.list.d/raspi.list

# update and upgrade
sudo apt-get update
sudo apt-get upgrade -y
</code></pre>
<p>安装后面需要的模块及软件：</p>
<pre><code class="language-sh">sudo apt-get install -y nginx python3-pip python3-rpi.gpio
sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple flask uwsgi
</code></pre>
<h1 id="3-调试继电器">3 调试继电器</h1>
<p>由于报警灯默认是用 220V 的交流电，上来直接测试，会有比较大的安全风险，所以我们这里先用 LED 灯来进行测试，如果成功，再将 LED 灯替换为报警灯。</p>
<h2 id="31-继电器">3.1 继电器</h2>
<p>继电器很简单，一端接树莓派进行开关控制，另外一端接设备，如图：</p>
<p><img src="https://winking324.github.io/post-images/1562645785924.png" alt=""></p>
<p>这个继电器对内是直接用树莓派的 5V 电压，对外可以接：</p>
<ul>
<li>10A 250V 交流电</li>
<li>10A 125V 交流电</li>
<li>10A 30V 直流电</li>
<li>10A 28V 的直流电</li>
</ul>
<p>从上图可以看到，对外三个接口对应的开关状态，中间接火线，如果希望默认开关长闭状态，对应左边；如果希望默认开关长开状态，对应右边。我们这里希望报警器默认是关闭的，所以接入右边。</p>
<h2 id="32-led">3.2 LED</h2>
<p>LED 灯就比较简单了，直接两个阵脚，一个接入 GPIO，一个接入负极。</p>
<p>最后整体如图：</p>
<p><img src="https://winking324.github.io/post-images/1562645777502.png" alt=""></p>
<h2 id="32-调试">3.2 调试</h2>
<p>这里用 Python3 简单调试一下，代码如下：</p>
<pre><code class="language-python">import RPi.GPIO as GPIO
import time

# GPIO 17
led_pin = 11
# GPIO 18
relay_pin = 12


def setup():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(led_pin, GPIO.OUT)
    GPIO.setup(relay_pin, GPIO.OUT)

    # led on
    GPIO.output(led_pin, GPIO.HIGH)
    # relay off
    GPIO.output(relay_pin, GPIO.LOW)


def loop():
    relay = 0
    while True:
        GPIO.output(relay_pin, GPIO.HIGH if relay == 1 else GPIO.LOW)
        time.sleep(2)
        relay = int(input('0: Close, 1: Open'))


def destroy():
    GPIO.output(led_pin, GPIO.LOW)
    GPIO.output(relay_pin, GPIO.LOW)

    # Release resource
    GPIO.cleanup()


if __name__ == '__main__':
    setup()
    try:
        loop()
    except KeyboardInterrupt:
        # When 'Ctrl+C' is pressed,
        # the child program destroy() will be  executed.
        destroy()
</code></pre>
<p>逻辑很简单，当输入 1 时，继电器进入闭合状态，LED 会亮起来；当输入 0 时，继电器进入打开状态，LED 会关闭。</p>
<h1 id="4-调试报警灯">4 调试报警灯</h1>
<p>链接报警灯：</p>
<p><img src="https://winking324.github.io/post-images/1562645797278.png" alt=""></p>
<p>当然这是初步连接，用于给大家展示接口，有需要尝试的小伙伴，一定要用电工胶布，把裸露的电线包好，避免出现意外事故。</p>
<p>连接好之后，插入电源，用下面的代码进行测试。</p>
<pre><code class="language-python">import RPi.GPIO as GPIO
import time

# GPIO 18
relay_pin = 12


def setup():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(relay_pin, GPIO.OUT)
    GPIO.output(relay_pin, GPIO.LOW)


def loop():
    relay = 0
    while True:
        GPIO.output(relay_pin, GPIO.HIGH if relay == 1 else GPIO.LOW)
        time.sleep(2)
        relay = int(input('0: Close, 1: Open'))


def destroy():
    GPIO.output(relay_pin, GPIO.LOW)
    GPIO.cleanup()


if __name__ == '__main__':
    setup()
    try:
        loop()
    except KeyboardInterrupt:
        destroy()
</code></pre>
<p>报警灯可以正常的进行工作：</p>
<p><img src="https://winking324.github.io/post-images/1562645805640.gif" alt=""></p>
<h1 id="5-报警服务">5 报警服务</h1>
<p>这里用 Nginx + uwsgi + flask 来搭建一个 web 服务，当有报警请求过来时，触发打开报警灯。</p>
<h2 id="51-nginx-配置">5.1 Nginx 配置</h2>
<p>在树莓派中执行以下命令：</p>
<pre><code class="language-sh">cd /etc/nginx/sites-enabled/
sudo mv default marmot.conf
</code></pre>
<p>修改 marmot.conf 文件，内容如下：</p>
<pre><code class="language-nginx">server {
        listen 80;
        listen [::]:80;

        location / {
                include        uwsgi_params;
                uwsgi_pass     127.0.0.1:5051;
                uwsgi_param UWSGI_CHDIR /home/pi/marmot;
                uwsgi_param UWSGI_SCRIPT app:app;
        }
}
</code></pre>
<p>重新加载 nginx 配置文件：</p>
<pre><code class="language-sh">sudo service nginx reload
</code></pre>
<h2 id="52-uwsgi-配置">5.2 uwsgi 配置</h2>
<p>创建 uwsgi 配置文件 <code>uwsgi_config.ini</code>：</p>
<pre><code class="language-ini">[uwsgi]
socket = 127.0.0.1:5051
master = true
project = /home/pi/marmot
pythonpath = %(project)
module = app
wsgi-file = %(project)/app.py
callable = app
processes = 1
threads = 1
daemonize = %(project)/server.log
stats = %(project)/uwsgi/uwsgi.status
pidfile = %(project)/uwsgi/uwsgi.pid
</code></pre>
<h2 id="53-报警服务">5.3 报警服务</h2>
<p>简单写一个 web 服务，有请求时，触发报警：</p>
<pre><code class="language-python">import time
import logging
import RPi.GPIO as GPIO
from flask import Flask


app = Flask(__name__, instance_relative_config=True)
app.logger.setLevel(logging.INFO)

# GPIO 18
relay_pin = 12


def setup_marmot():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(relay_pin, GPIO.OUT)
    GPIO.output(relay_pin, GPIO.LOW)

    
def destroy_marmot():
    GPIO.output(relay_pin, GPIO.LOW)
    GPIO.cleanup()
    
    
@app.route('/')
def marmot():
    app.logger.info('what does the marmot say')
    setup_marmot()
    GPIO.output(relay_pin, GPIO.HIGH)
  	time.sleep(5)
    destroy_marmot()
    return 'Ahhhhhhhhhhhhhhh...'


if __name__ == '__main__':
    app.run()
</code></pre>
<p>启动服务：</p>
<pre><code class="language-sh">uwsgi --ini uwsgi_config.ini
</code></pre>
<p>在浏览器里面，输入树莓派的地址，发送请求测试，报警成功。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派红外模块对接]]></title>
        <id>https://winking324.github.io/post/raspberry-lirc</id>
        <link href="https://winking324.github.io/post/raspberry-lirc">
        </link>
        <updated>2019-07-04T04:56:38.000Z</updated>
        <summary type="html"><![CDATA[<p>随着家里的电器越来越多，遥控器也越来越多，例如投影仪遥控、电视盒子遥控、HDMI 分线器遥控、NAS 存储遥控、音响遥控、电灯遥控、小夜灯遥控、空调遥控等等。所以当我想看一部电影时，需要用先打开投影仪，再打开电视盒子，然后打开 NAS 存储，接着打开 HDMI 分线器，跟着打开音响，甚至还要关上电灯。</p>
<p>一系列的操作简直烦不胜烦，然后就想是不是可以用一个遥控器，控制所有电器呢？毕竟大部分电器的遥控器，无非也就是按一下开关键而已。</p>
]]></summary>
        <content type="html"><![CDATA[<p>随着家里的电器越来越多，遥控器也越来越多，例如投影仪遥控、电视盒子遥控、HDMI 分线器遥控、NAS 存储遥控、音响遥控、电灯遥控、小夜灯遥控、空调遥控等等。所以当我想看一部电影时，需要用先打开投影仪，再打开电视盒子，然后打开 NAS 存储，接着打开 HDMI 分线器，跟着打开音响，甚至还要关上电灯。</p>
<p>一系列的操作简直烦不胜烦，然后就想是不是可以用一个遥控器，控制所有电器呢？毕竟大部分电器的遥控器，无非也就是按一下开关键而已。</p>
<!-- more -->
<p>所以计划用树莓派和红外模块来进行电器的整体控制。</p>
<h1 id="1-红外模块">1 红外模块</h1>
<p>树莓派已经有了，那现在缺的是一个红外模块，所以先淘宝和各种论坛搜了一下，找到了这个不错的红外模块。</p>
<p><img src="https://winking324.github.io/post-images/1562216778147.png" alt=""></p>
<p>这个模块有接收和发送两个部分，另外让淘宝老板多加了一个红外发射器 D2，到货时，老板已经贴心的帮忙焊了上去。</p>
<p>但是我的树莓派加了一个合金的外壳，并且有散热风扇，如下：</p>
<p><img src="https://winking324.github.io/post-images/1562216791197.png" alt=""></p>
<p>另外看了一下树莓派阵脚的定义，如下（这个是扩展模块，每一列都是一样的，所以只看一列就可以了）：</p>
<p><img src="https://winking324.github.io/post-images/1562216808667.png" alt=""></p>
<p>就会有两个问题：</p>
<ol>
<li>插上这个模块，需要把外壳移除；</li>
<li>这个模块占用了 5v 正极，导致散热风扇也没法用；</li>
</ol>
<p>所以大概看了一下红外模块的阵脚，发现其实它只用了以下几个阵脚：</p>
<ol>
<li>3.3v：正极；</li>
<li>GND：负极；</li>
<li>P17：红外发射；</li>
<li>P18：红外接收；</li>
<li>P27：开关1；</li>
<li>P22：开关2；</li>
</ol>
<p>所以用排线把这几个阵脚对应连起来就可以了，这样好处就是解决了上面的两个问题，但是缺点是加了排线，导致整体看起来比较乱，不够精简。不过后面可以放到自制的盒子里面，把这些遮挡起来，就可以解决了。</p>
<p>具体的阵脚链接，大家可以参考：</p>
<p><img src="https://winking324.github.io/post-images/1562216822476.png" alt=""></p>
<p><img src="https://winking324.github.io/post-images/1562216832768.png" alt=""></p>
<h1 id="2-测试模块">2 测试模块</h1>
<p>接线结束后，首先要测试一下模块是不是工作正常，如果整体工作正常，才能细化各部分逻辑。否则开发了半天，发现模块工作不正常，各种事情都要返工，就得不偿失了。</p>
<p>测试过程中，查了不少资料，也绕了不少弯路，主要问题总结如下：</p>
<ol>
<li>
<p>很多资料比较老，在内核 4.19.x 以上版本，都不能跟资料介绍的那样正常工作；</p>
<p>由于在内核 4.19.x 以上版本，移除了对 <code>dtoverlay=lirc-rpi</code> 的支持，改为 <code>dtoverlay=gpio-ir</code> 以及 <code>dtoverlay=gpio-ir-tx</code> 方式。所以如果查看资料中，是以 <code>lirc-rpi</code> 方式集成的，那就可以无视这个资料了；</p>
</li>
<li>
<p>lirc 这个模块的最新版本，配置也跟之前老版本的不同，不需要 <code>/etc/lirc/hardware.conf</code> 等配置文件；</p>
</li>
</ol>
<p>踩了好多坑，正确的姿势应该按照下面的步骤执行。</p>
<h2 id="21-确认内核版本">2.1 确认内核版本</h2>
<pre><code class="language-sh">uname -a
# 输出如下
# Linux raspberrypi 4.14.79-v7+ #1159 SMP Sun Nov 4 17:50:20 GMT 2018 armv7l GNU/Linux
</code></pre>
<p>对于输出内容的说明如下：</p>
<ul>
<li><code>Linux</code>：kernel name</li>
<li><code>raspberrypi</code>：network node hostname</li>
<li><code>4.14.79-v7+</code>：kernel release</li>
<li><code>#1159 SMP Sun Nov 4 17:50:20 GMT 2018</code>：kernel version</li>
<li><code>armv7l</code>：machine hardware name</li>
<li><code>GNU/Linux</code>：operating system</li>
</ul>
<p>可以看到当前的内核版本为 <code>4.14.79-v7+</code>。打开 <code>/boot/overlays/README</code> 并搜索 <code>lirc-rpi</code> 后，发现：</p>
<pre><code>Name:   lirc-rpi
Info:   This overlay has been deprecated and removed - see gpio-ir
Load:   &lt;Deprecated&gt;
</code></pre>
<p><code>lirc-rpi</code> 已经被标记成已废弃，并且==已经移除==，使用 <code>gpio-ir</code> 来替换。</p>
<p>所以首先要先确认自己的内核版本，并查看 <code>/boot/overlays/README</code>，确定 <code>lirc-rpi</code> 在自己的系统上是否可用（如果可用的话，可以直接找相关的集成文档，这部分有很多资料，这里就不多说了）。</p>
<h2 id="22-安装-lirc">2.2 安装 lirc</h2>
<p><a href="http://www.lirc.org/">lirc</a> 是 Linux 下，提供红外信号编解码，以及收发能力的一个模块。有了这个模块，我们不需要去实现红外信号处理等很复杂的逻辑。</p>
<p>安装：</p>
<pre><code class="language-sh">sudo apt-get install -y lirc
</code></pre>
<h2 id="23-配置-gpio">2.3 配置 gpio</h2>
<p>首先，配置 gpio，让系统知道红外模块是通过哪几个引脚来进行控制的。</p>
<p>在前面，我们在接线的时候，提到：</p>
<ul>
<li>
<p>P17：红外发射；</p>
</li>
<li>
<p>P18：红外接收；</p>
</li>
</ul>
<p>所以需要将这两个引脚配置到系统中。</p>
<pre><code class="language-sh"># 打开编辑 /boot/config.txt 文件
sudo vi /boot/config.txt

# 找到 dtoverlay 的声明位置，增加以下声明
dtoverlay=gpio-ir,gpio_pin=18
dtoverlay=gpio-ir-tx,gpio_pin=17

# 保存退出，并重启树莓派
sudo reboot
</code></pre>
<p>重启后，进入系统，执行 <code>ls /dev</code> 可以看到 <code>lirc0</code> 和 <code>lirc1</code> 这两个设备，说明配置成功。</p>
<h2 id="24-测试红外接收">2.4 测试红外接收</h2>
<p>停掉 lircd 服务：</p>
<pre><code class="language-sh">sudo systemctl stop lircd.socket
sudo systemctl stop lircd.service
</code></pre>
<p>读取红外模块接收的内容：</p>
<pre><code class="language-sh">mode2 --driver default --device /dev/lirc1
</code></pre>
<p>进入红外读取状态：</p>
<pre><code class="language-sh">Using driver devinput on device /dev/lirc1
Trying device: /dev/lirc1
Using device: /dev/lirc1
</code></pre>
<p>然后用遥控器随便按一个键，会出现以下内容：</p>
<pre><code class="language-sh">space 16777215
pulse 95
space 182
pulse 1616
space 221
pulse 766
space 76
pulse 443
space 277
pulse 149
space 387
pulse 908
space 168
pulse 94
space 348
pulse 741
space 80
pulse 738
space 485
pulse 82
space 152
pulse 344
space 74
pulse 132
space 4898
pulse 515
space 641
pulse 443
space 748
pulse 94
space 170
pulse 89
space 1894
pulse 383
space 647
pulse 86
space 256
pulse 179
space 797
pulse 89
space 944
pulse 198
space 1061
pulse 314
space 1883
pulse 257
space 1861
pulse 116
space 224
pulse 84
space 1884
pulse 454
space 1698
pulse 87
space 175
pulse 120
space 1932
pulse 476
space 1778
pulse 496
space 1802
pulse 96
space 2153
pulse 355
space 1953
pulse 375
space 591
pulse 545
space 1726
pulse 334
space 933
pulse 386
space 643
pulse 493
space 643
pulse 386
space 2091
pulse 239
space 641
pulse 340
space 798
pulse 486
space 1779
pulse 496
space 747
pulse 90
space 2209
pulse 308
space 1805
pulse 84
space 115
pulse 241
space 1751
pulse 87
space 175
pulse 174
space 719
pulse 471
space 1857
pulse 92
pulse 21981
space 61979
space 40451
pulse 89
space 143
pulse 96
space 221
pulse 904
space 121
pulse 1057
space 84
pulse 2610
space 303
pulse 1550
space 83
pulse 95
space 188
pulse 1004
space 2820
pulse 381
pulse 19764
</code></pre>
<h2 id="25-测试红外发送">2.5 测试红外发送</h2>
<p>waiting for update</p>
<h1 id="3-参考链接">3 参考链接</h1>
<ul>
<li>
<p><a href="http://www.lirc.org/">LIRC</a></p>
</li>
<li>
<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=235256">Using LIRC with kernel 4.19.X and gpio-ir</a></p>
</li>
<li>
<p><a href="https://superuser.com/questions/1441396/rpi-3b-lirc-wont-setup-device-could-not-get-file-information-for-dev-lirc0">RPi 3B — LIRC won't setup device: could not get file information for /dev/lirc0</a></p>
</li>
<li>
<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=235918">lirc on Raspberry Pi Zero W with gpio-ir</a></p>
</li>
<li>
<p><a href="https://www.sunfounder.com/learn/sensor-kit-v2-0-for-raspberry-pi-b-plus/lesson-23-ir-remote-control-sensor-kit-v2-0-for-b-plus.html">Lesson 23 IR Remote Control</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx + uWSGI + Flask + WebSocket]]></title>
        <id>https://winking324.github.io/post/nginx-uwsgi-flask-websocket</id>
        <link href="https://winking324.github.io/post/nginx-uwsgi-flask-websocket">
        </link>
        <updated>2019-07-02T11:31:38.000Z</updated>
        <summary type="html"><![CDATA[<p>一个应用服务器，想要提供短链接和长连接两类服务类型时，一般短链接用 HTTP 方式，而长链接采用 WebSocket 方式。</p>
<p>所以用 Flask 如何提供这两种服务类型呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个应用服务器，想要提供短链接和长连接两类服务类型时，一般短链接用 HTTP 方式，而长链接采用 WebSocket 方式。</p>
<p>所以用 Flask 如何提供这两种服务类型呢？</p>
<!-- more -->
<p>这里使用 <a href="https://github.com/zeekay/flask-uwsgi-websocket">Flask-uWSGI-WebSocket</a> 这个插件，采用 Nginx + uWSGI + Flask + WebSocket 的方式来提供 HTTP 和 WebSocket 两种服务类型。</p>
<ol>
<li>
<p>安装 Flask-uWSGI-WebSocket 插件；</p>
<pre><code class="language-sh">sudo pip3 install Flask-uWSGI-WebSocket
</code></pre>
</li>
<li>
<p>修改 uwsgi 配置文件：</p>
<pre><code class="language-ini">[uwsgi]
socket = 127.0.0.1:5051
master = true
project = /data/projects/flaskr/
pythonpath = %(project)
module = app
wsgi-file = %(project)/app.py
callable = app
processes = 1
threads = 1
daemonize = %(project)/server.log
stats = %(project)/uwsgi/uwsgi.status
pidfile = %(project)/uwsgi/uwsgi.pid

# 增加
gevent = 100
</code></pre>
</li>
<li>
<p>修改 Flask 相关逻辑；</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
__author__ = &quot;winking324@gmail.com&quot;
__copyright__ = &quot;Copyright (c) 2019 winking.io, Inc.&quot;


from flask import Flask
from flask_uwsgi_websocket import GeventWebSocket


app = Flask(__name__, instance_relative_config=True)
websocket = GeventWebSocket(app)


@app.route('/')
def hello_world():
    return 'Hello World!'

  
@websocket.route('/echo')
def echo(ws):
    while True:
        msg = ws.receive()
        if msg is not None:
            if msg:
                ws.send(msg)
        else:
            return

              
if __name__ == '__main__':
    app.run()
</code></pre>
</li>
<li>
<p>重启 uwsgi；</p>
<pre><code class="language-sh">uwsgi --reload /data/projects/flaskr/uwsgi/uwsgi.pid
</code></pre>
</li>
<li>
<p>测试 WebSocket 服务；</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx + uWSGI + Flask]]></title>
        <id>https://winking324.github.io/post/nginx-uwsgi-flask</id>
        <link href="https://winking324.github.io/post/nginx-uwsgi-flask">
        </link>
        <updated>2019-07-02T11:00:29.000Z</updated>
        <summary type="html"><![CDATA[<p>上次说到了 Flask，接触到 uWSGI。在实际生产环境，一般采用 Nginx + uWSGI + Flask 的组合方式：</p>
<ul>
<li>Nginx 负责提供对外的 Web 服务；</li>
<li>uWSGI 充当中间件，桥接对外的 Web 服务和实际的应用服务；</li>
<li>Flask 提供应用服务，完成业务逻辑；</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>上次说到了 Flask，接触到 uWSGI。在实际生产环境，一般采用 Nginx + uWSGI + Flask 的组合方式：</p>
<ul>
<li>Nginx 负责提供对外的 Web 服务；</li>
<li>uWSGI 充当中间件，桥接对外的 Web 服务和实际的应用服务；</li>
<li>Flask 提供应用服务，完成业务逻辑；</li>
</ul>
<!-- more -->
<h1 id="1-nginx-配置">1 Nginx 配置</h1>
<p>在这里，使用 Nginx 的主要目的如下：</p>
<ol>
<li>安全。客户端对 Web 服务器的访问需要先经过 Nginx。这样可以防止外部程序直接对应用服务器的恶意攻击；</li>
<li>负载均衡。在有多个应用服务器的情况下，Nginx 可以根据应用服务器的负载情况，动态地把请求交给不同的应用服务器来处理；</li>
<li>提升 IO 性能。一个 HTTP 请求的数据，从客户端传输给服务器，是需要时间的，例如 N 秒，如果直接传给应用服务器，应用服务器就需要让一个进程（或线程）阻塞 N 秒，进行 IO 操作，这样会降低应用服务器的性能。如果先让 Nginx 接收完整的 HTTP 请求，再把请求发给应用服务器，就能提升应用服务器的性能。还有一些静态文件的请求，可以直接交给 Nginx 来处理，不需要经过应用服务器，降低了应用服务器的 QPS。</li>
</ol>
<p>但是默认情况下，Nginx 不具备 WSGI 规范的能力，需要通过 <a href="http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html">ngx_http_uwsgi_module</a> 模块进行扩展，这个模块默认已经集成在 Nginx，所以不需要重新编译 Nginx。</p>
<pre><code class="language-sh"># 修改 Nginx 配置
sudo vi /etc/nginx/sites-enabled/default

# 修改 location 部分
location / {
	include        uwsgi_params;
	uwsgi_pass     127.0.0.1:5051;
	uwsgi_param UWSGI_CHDIR  /data/projects/flaskr;
	uwsgi_param UWSGI_SCRIPT app:app;
}

# 保存配置，并重新加载
sudo systemctl reload nginx
</code></pre>
<h1 id="2-uwsgi-配置">2 uWSGI 配置</h1>
<p>Python 默认情况下，没有 uWSGI，所以需要手动安装一下：</p>
<pre><code class="language-sh">sudo pip3 install uwsgi
</code></pre>
<p>之后，在 Flask 项目中，创建 uWSGI 的配置文件 <code>/data/projects/flaskr/uwsgi_config.ini</code>，并配置如下：</p>
<pre><code class="language-ini">[uwsgi]
socket = 127.0.0.1:5051
master = true
project = /data/projects/flaskr/
pythonpath = %(project)
module = app
wsgi-file = %(project)/app.py
callable = app
processes = 1
threads = 1
daemonize = %(project)/server.log
stats = %(project)/uwsgi/uwsgi.status
pidfile = %(project)/uwsgi/uwsgi.pid
</code></pre>
<h1 id="3-flask-应用">3 Flask 应用</h1>
<p>编写一个简单的 Flask 应用，先用来测试。创建 <code>/data/projects/flaskr/app.py</code> 文件，并输入：</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
__author__ = &quot;winking324@gmail.com&quot;
__copyright__ = &quot;Copyright (c) 2019 winking.io, Inc.&quot;


from flask import Flask


app = Flask(__name__, instance_relative_config=True)


@app.route('/')
def hello_world():
    return 'Hello World!'


if __name__ == '__main__':
    app.run()
</code></pre>
<p>使用 uwsgi 命令启动 Flask 应用服务：</p>
<pre><code class="language-sh">uwsgi --ini /data/projects/flaskr/uwsgi_config.ini
</code></pre>
<p>如果需要重启 uwsgi，使用：</p>
<pre><code class="language-sh">uwsgi --reload /data/projects/flaskr/uwsgi/uwsgi.pid
</code></pre>
<p>如果需要停止服务，使用：</p>
<pre><code class="language-sh">uwsgi --stop /data/projects/flaskr/uwsgi/uwsgi.pid
</code></pre>
<h1 id="4-请求测试">4 请求测试</h1>
<p>在浏览器中，访问对应 Nginx 的地址，会在浏览器中显示 <code>Hello world!</code>。</p>
<h1 id="5-参考链接">5 参考链接</h1>
<ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html">ngx_http_uwsgi_module 说明文档</a></li>
<li><a href="https://www.cnblogs.com/cuchadanfan/p/6237584.html">ngx_http_uwsgi_module 中文文档</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WSGI + uWSGI + uwsgi]]></title>
        <id>https://winking324.github.io/post/uwsgi</id>
        <link href="https://winking324.github.io/post/uwsgi">
        </link>
        <updated>2019-06-28T05:36:18.000Z</updated>
        <summary type="html"><![CDATA[<p>一直以来，给外部系统提供服务，都是使用 RESTful API 方式。但是对于更多的用户来说，更喜欢的是使用浏览器直接打开页面，点击几个按钮来操作。所以在此基础上，学习了一下 Flask，接触到了 uWSGI，这里进行总结一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一直以来，给外部系统提供服务，都是使用 RESTful API 方式。但是对于更多的用户来说，更喜欢的是使用浏览器直接打开页面，点击几个按钮来操作。所以在此基础上，学习了一下 Flask，接触到了 uWSGI，这里进行总结一下。</p>
<!-- more -->
<h2 id="wsgi">WSGI</h2>
<p>说到 uWSGI，需要先理解一下 WSGI。</p>
<p>对于一个 Web 服务来说，处理用户的请求的过程如下：</p>
<ol>
<li>用户使用浏览器，发起 HTTP 请求；</li>
<li>Web 服务器根据接收到请求，生成对应的 HTML 文档；</li>
<li>Web 服务器将 HTML 文档，作为 Response 发送给浏览器；</li>
<li>浏览器收到 HTML 文档，渲染展示出来给用户；</li>
</ol>
<p>对于静态页面，即 HTML 文档内容固定不变，可以用现在很成熟的 Nginx 等 Web 服务器来实现。</p>
<p>对于动态页面，即 HTML 文档需要根据不同用户请求的不同内容来生成，就需要自己来实现 Web 服务器了。但是如果对于基本的 HTTP 协议都去开发一遍的话，工作量就太大了。</p>
<p>所以更好的方式是，由 Nginx 这些成熟的 Web 服务器来负责接收处理 HTTP 等请求，而我们自己的应用程序，专心负责生成对应的 HTML 文档，这就是 WSGI 的意义了。</p>
<p>WSGI（Web Server Gateway Interface），是 Python 应用程序（或框架）与 Web 服务器之间的一种接口规范。只要遵循这个接口规范，开发者实现的 Python 应用程序就可以和 Web 服务器进行对接。</p>
<p>WSGI 是专指 Python 和 Web 服务器之间的接口规范，同时还有其他例如 CGI、FastCGI、Servlet等规范，其对比如下：</p>
<table>
<thead>
<tr>
<th>规范</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CGI</td>
<td>Common Gateway Interface，最早出现的外部扩展应用程序与 Web 服务器交互的标准接口。</td>
</tr>
<tr>
<td>FastCGI</td>
<td>FastCGI 是 CGI 的优化版本，CGI 每次执行都需要 fork 一次，效率很低，而 FastCGI 是常驻类型，且支持分布式的运算，大大提高了性能。</td>
</tr>
<tr>
<td>Servlet</td>
<td>Java 专用的外部扩展应用程序与 Web 服务器交互的标准接口。</td>
</tr>
<tr>
<td>WSGI</td>
<td>Python 专用的外部扩展应用程序与 Web 服务器交互的标准接口。</td>
</tr>
</tbody>
</table>
<h2 id="uwsgi">uWSGI</h2>
<p>uWSGI 是一个遵循 WSGI 规范的 Web 服务器，它实现了 WSGI、uwsgi、HTTP 等协议。</p>
<h2 id="uwsgi-2">uwsgi</h2>
<p>uwsgi 是 uWSGI 服务器使用的本地协议。</p>
<p>uwsgi 是一个二进制协议，可以携带任何类型的数据。一个 uwsgi 分组的前 4 个字节，描述了这个分组包含的数据类型。</p>
<p>由于 uwsgi 使用二进制来存储数据，比 FastCGI 这种字符存储数据，在存储空间和解析速度上有很大的优势。</p>
<h2 id="参考地址">参考地址</h2>
<ul>
<li><a href="https://www.jianshu.com/p/29f66eb4e55a">说说我对 WSGI 的理解</a></li>
<li><a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/index.html">uWSGI 项目文档</a></li>
<li><a href="https://www.cnblogs.com/Xjng/p/aa4dd23918359c6414d54e4b972e9081.html">Nginx+uWSGI+Django原理</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐讯 N1 盒子刷机]]></title>
        <id>https://winking324.github.io/post/reinstall-n1</id>
        <link href="https://winking324.github.io/post/reinstall-n1">
        </link>
        <updated>2019-06-16T09:50:25.000Z</updated>
        <summary type="html"><![CDATA[<p>现在市面上的各种盒子，广告很多，体验很差。618 入了一个明基投影仪，打算买一个盒子的前提下，刚好好多朋友推荐斐讯 N1 盒子，优点是性能很强大，价格便宜，刷机后非常给力。</p>
]]></summary>
        <content type="html"><![CDATA[<p>现在市面上的各种盒子，广告很多，体验很差。618 入了一个明基投影仪，打算买一个盒子的前提下，刚好好多朋友推荐斐讯 N1 盒子，优点是性能很强大，价格便宜，刷机后非常给力。</p>
<!-- more -->
<p>所以从拼多多上入了一个 N1 盒子 + T1 原装遥控器 + 刷机线，总价 119.9 元（斐讯在淘宝/京东/咸鱼/拼多多上都已经被屏蔽，需要搜索 N1 盒子来查找）。</p>
<h2 id="1-刷机准备">1 刷机准备</h2>
<p>设备：</p>
<ol>
<li>N1 盒子一台；</li>
<li>刷机线一根；</li>
<li>显示器一台；</li>
<li>网线一根；</li>
<li>鼠标一个；</li>
<li>Windows 电脑一台；</li>
<li>网络环境；</li>
</ol>
<p>工具：</p>
<ol>
<li>系统降级工具；</li>
<li>进入线刷模式工具；</li>
<li>刷机软件：UsbBurningTool；</li>
<li>刷机系统 Rom；</li>
<li>驱动人生；</li>
</ol>
<h2 id="2-系统降级">2 系统降级</h2>
<p>由于 N1 最新的系统固件，已经被加密，所以在不降级的前提下，无法进行刷机。</p>
<ol>
<li>
<p>N1 连接显示器/网线/鼠标/电源，开机，进入以下界面；</p>
<p><img src="https://winking324.github.io/post-images/1561197081153.jpg" alt=""></p>
</li>
<li>
<p>鼠标连续点击固件版本这行字，直到出现下方“打开adb”；</p>
</li>
<li>
<p>连接刷机线，注意 N1 盒子是对应 HDMI 旁边 USB 口；</p>
</li>
<li>
<p>在 Windows 上，打开驱动人生，打开外设驱动，安装安卓驱动；</p>
<p><img src="https://winking324.github.io/post-images/1561340510118.jpg" alt=""></p>
</li>
<li>
<p>在 Windows 电脑上，解压 《N1-T1降刷机助手v1.1版本》压缩包；</p>
</li>
<li>
<p>进入解压后的目录中，运行 <code>T1_N1降级工具v1.1.exe</code>；</p>
<p><img src="https://winking324.github.io/post-images/1561340522634.jpg" alt=""></p>
</li>
<li>
<p>选择降级设备为 N1，设备 IP 为 N1 盒子对应的 IP，点击开始降级；</p>
</li>
<li>
<p>没有意外的话，最终工作状态会显示为降级成功；</p>
</li>
<li>
<p>断开 USB 和电源，重启 N1 盒子；</p>
</li>
<li>
<p>重启后，进入初始界面，但是上面固件版本仍然为原来的版本，这个不要在意，因为刷机的固件版本，跟显示的这个固件版本，是两个东西，只要降级工具里面显示成功即可；</p>
</li>
</ol>
<h2 id="3-刷机">3 刷机</h2>
<p>系统降级成功后，可以选择需要的 Rom 进行刷机，常见的 Rom 有很多，大家可以自行百度查找适合自己的 Rom，这里以常见的《斐讯盒子N1_YYFROM讯飞语音实用版190421》进行示例。</p>
<ol>
<li>
<p>连接刷机线；</p>
</li>
<li>
<p>安装 UsbBurningTool，软件会自动安装 USB 驱动；</p>
<p><img src="https://winking324.github.io/post-images/1561340535289.jpg" alt=""></p>
</li>
<li>
<p>打开 UsbBurningTool，在“文件”中加载刷机包，加载完成后，点击开始按钮（<strong>注意擦除 FLASH 和擦除Bootloader 前面的对号要去掉</strong>）；</p>
<p><img src="https://winking324.github.io/post-images/1561340546055.jpg" alt=""></p>
</li>
<li>
<p>解压《使N1进入线刷模式》压缩包，双击运行 <code>reboot_to_usb_burn/进入线刷模式.bat</code> 脚本；</p>
</li>
<li>
<p>这时候盒子会进入重启状态（如果显示器有内容显示，先不要管），对应 Windows 电脑会有 USB 设备插入的提示声；</p>
</li>
<li>
<p>XP 以上 Windows 系统，需要手动添加驱动；</p>
</li>
<li>
<p>在我的电脑上右键，选择管理，并打开设备管理器，然后在操作中，添加过时硬件；</p>
<p><img src="https://winking324.github.io/post-images/1561340557223.jpg" alt=""></p>
<p><img src="https://winking324.github.io/post-images/1561340568358.jpg" alt=""></p>
<p><img src="https://winking324.github.io/post-images/1561340578604.jpg" alt=""></p>
<p><img src="https://winking324.github.io/post-images/1561340586822.jpg" alt=""></p>
</li>
<li>
<p>驱动安装完成后，N1 进行断电重启；</p>
</li>
<li>
<p>重启后，重新运行  <code>reboot_to_usb_burn/进入线刷模式.bat</code> 脚本；</p>
</li>
<li>
<p>这时候，UsbBurningTool 可以识别到设备，并开始进行刷机；</p>
<p><img src="https://winking324.github.io/post-images/1561340596193.jpg" alt=""></p>
</li>
<li>
<p>刷机完成后，关掉 UsbBurningTool，并断电重启 N1，之后可以进入刷机的系统；</p>
<p><img src="https://winking324.github.io/post-images/1561340605374.jpg" alt=""></p>
</li>
</ol>
<h2 id="4-参考地址">4 参考地址</h2>
<ul>
<li><a href="https://www.right.com.cn/forum/thread-318044-1-1.html">斐讯天天链N1刷机小白教程</a></li>
<li><a href="https://www.right.com.cn/forum/thread-336688-1-1.html">T1_N1一键降级工具v1.1版本</a></li>
<li><a href="https://pan.baidu.com/s/11ll1an5qHuYKTIIotuRuwA">其他工具(czez)</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu 下 Let's Encrypt 生成 HTTPS 证书]]></title>
        <id>https://winking324.github.io/post/lets-encrypt</id>
        <link href="https://winking324.github.io/post/lets-encrypt">
        </link>
        <updated>2019-06-13T09:38:31.000Z</updated>
        <summary type="html"><![CDATA[<p>Let's Encrypt 这个认证机构，可以提供期限是 90 天的免费证书，且可以无限次更新，本文介绍如何使用 Let's Encrypt 来使自己的网站支持 HTTPS。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Let's Encrypt 这个认证机构，可以提供期限是 90 天的免费证书，且可以无限次更新，本文介绍如何使用 Let's Encrypt 来使自己的网站支持 HTTPS。</p>
<!-- more -->
<p>想要创建一个 HTTPS 的网站，需要以下几个步骤：</p>
<ol>
<li>一个域名；</li>
<li>一个外网可以访问的服务器；</li>
<li>一个认证的证书；</li>
</ol>
<h1 id="1-下载并初始化-certbot">1 下载并初始化 Certbot</h1>
<p>Certbot 是 Let's Encrypt 官方提供的工具，直接通过工具可以自动化生成证书。</p>
<pre><code class="language-sh"># 下载 Certbot
wget https://dl.eff.org/certbot-auto

# 设置为可执行程序
chmod a+x certbot-auto

# 移动到官方推荐目录下
sudo mv certbot-auto /usr/local/bin

# 修改用户及用户组
sudo chown root:root /usr/local/bin/certbot-auto

# 执行初始化
sudo certbot-auto
</code></pre>
<p>由于初始化需要安装很多 Python 的库，这个过程可能会比较漫长，如果需要，可以通过优化 Python 的源来进行加速。</p>
<pre><code class="language-sh"># 创建 pip 配置目录
sudo mkdir ~/.pip

# 创建 pip 配置
touch ~/.pip/pip.conf

# 输入以下内容到 pip.conf 中
[global]
index-url=http://mirrors.aliyun.com/pypi/simple/
[install]
trusted-host=mirrors.aliyun.com
</code></pre>
<h1 id="2-创建-nginx-服务">2 创建 Nginx 服务</h1>
<p>在漫长的初始化过程中，可以先执行下一步操作。在生成证书时，一般有两种模式可以选择：</p>
<ul>
<li>webroot：在已有的 HTTP 服务中增加 HTTPS；</li>
<li>standalone：帮助创建带有 HTTPS 的服务；</li>
</ul>
<p>这里我们选择使用 webroot 模式，所以我们需要事先准备好一个 HTTP 服务。</p>
<pre><code class="language-sh"># 安装 Nginx
sudo apt install nginx

# 创建 HTTP Root 路径
sudo mkdir /var/www/winking

# 修改 Nginx 配置
sudo vi /etc/nginx/sites-enabled/default

# 将 root 修改为
root /var/www/winking;

# 保存配置，并重新加载
sudo systemctl reload nginx
</code></pre>
<h1 id="3-创建-certbot-配置">3 创建 Certbot 配置</h1>
<p>这个时候，Certbot 应该已经初始化完成了，可以生产证书文件了。</p>
<p>首先，我们创建 Certbot 的配置，来指导生产证书文件。</p>
<pre><code class="language-sh"># 创建配置文件路径
sudo mkdir -p /etc/letsencrypt/configs

# 创建配置文件，并编辑
sudo vi /etc/letsencrypt/configs/winking.io.conf

# 输入配置内容
domains = winking.io
rsa-key-size = 2048
email = your-email@example.com
text = True
authenticator = webroot
webroot-path = /var/www/winking
</code></pre>
<p>其中，webroot-path 是我们在上一步中创建的 HTTP Root 路径。在生成证书的过程中，Certbot 会在这个路径中自动生成一个文件，来进行验证域名配置的正确性。</p>
<h1 id="4-生成证书">4 生成证书</h1>
<p>调用 Certbot，并根据配置来生成证书。</p>
<pre><code class="language-sh">sudo certbot-auto -c /etc/letsencrypt/configs/winking.io.conf certonly
</code></pre>
<p>运行顺利，则会在 <code>/etc/letsencrypt/live/winking.io/</code> 这个路径下，生成以下几个文件：</p>
<ul>
<li>cert.pem</li>
<li>privkey.pem</li>
<li>chain.pem</li>
<li>fullchain.pem</li>
</ul>
<h1 id="5-配置-https">5 配置 HTTPS</h1>
<p>顺利生成证书后，我们需要将 Nginx 的 HTTP 服务，修改为 HTTPS 服务。</p>
<pre><code class="language-sh"># 修改 Nginx 配置文件
sudo vi /etc/nginx/sites-enabled/default

# 增加以下内容
listen 443 ssl default_server;
listen [::]:443 ssl default_server;
ssl_certificate /etc/letsencrypt/live/miai.winking.io/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/miai.winking.io/privkey.pem;

# 保存配置，并重新加载
sudo systemctl reload nginx
</code></pre>
<p>这样，就可以用 HTTPS 的方式打开你的网站了。</p>
<h1 id="6-参考">6 参考</h1>
<ul>
<li><a href="https://ksmx.me/letsencrypt-ssl-https/">LET'S ENCRYPT 给网站加 HTTPS 完全指南</a></li>
<li><a href="https://www.linuxidc.com/Linux/2017-03/142248.htm">部署Let’s Encrypt免费SSL证书&amp;&amp;自动续期</a></li>
<li><a href="https://www.jianshu.com/p/3c67562b88a5">使用let's encrypt工具配置Nginx HTTPS</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu 下 Samba 安装与配置]]></title>
        <id>https://winking324.github.io/post/ubuntu-samba</id>
        <link href="https://winking324.github.io/post/ubuntu-samba">
        </link>
        <updated>2019-02-19T09:25:51.000Z</updated>
        <summary type="html"><![CDATA[<p>SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。</p>
]]></summary>
        <content type="html"><![CDATA[<p>SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。</p>
<!-- more -->
<p>Samba 是在 Linux 和 UNIX 系统上实现 SMB 协议的一个免费软件，由服务器及客户端程序构成。</p>
<ol>
<li>
<p>安装 Samba 服务；</p>
<p><code>sudo apt-get install samba</code></p>
</li>
<li>
<p>添加系统用户 <code>share</code>；</p>
<p><code>sudo adduser share</code></p>
</li>
<li>
<p>为该用户创建 Samba 密码；</p>
<p><code>sudo smbpasswd -a share</code></p>
</li>
<li>
<p>修改 Samba 配置，设置更新目录；</p>
<p><code>sudo vi /etc/samba/smb.conf</code></p>
<pre><code>[share]
   comment = Share
   path = /data/share
   public = yes
   writable = yes
   guest ok = no
   valid user = share
</code></pre>
</li>
<li>
<p>重启 Samba 服务；</p>
<p><code>sudo service samba restart</code></p>
</li>
<li>
<p>客户端连接；</p>
<p>在文件浏览器中，打开 <code>smb://192.168.100.110</code> 以访问对应的 Samba 文件服务器。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Raspberry Pi 初始化]]></title>
        <id>https://winking324.github.io/post/raspberry-pi-init</id>
        <link href="https://winking324.github.io/post/raspberry-pi-init">
        </link>
        <updated>2019-02-19T09:14:29.000Z</updated>
        <summary type="html"><![CDATA[<p>树莓派是一款基于 ARM 的微型电脑主板，具备所有 PC 的基本功能。默认情况下其系统基于 Linux，可以在树莓派上安装一些简单的服务，提供访问。</p>
]]></summary>
        <content type="html"><![CDATA[<p>树莓派是一款基于 ARM 的微型电脑主板，具备所有 PC 的基本功能。默认情况下其系统基于 Linux，可以在树莓派上安装一些简单的服务，提供访问。</p>
<!-- more -->
<h1 id="1-安装系统">1 安装系统</h1>
<ol>
<li>从官网<a href="https://www.raspberrypi.org/downloads/">下载页面</a>下载系统镜像文件；</li>
<li>下载镜像烧录软件，Mac 上可以使用 <a href="https://www.balena.io/etcher/">balenaEtcher</a>；</li>
<li>将镜像烧录到 SD 卡上；</li>
<li>将 SD 卡查到树莓派上，上电启动；</li>
</ol>
<p>注意:</p>
<ol>
<li>树莓派默认情况下只支持从 SD 卡上启动系统；</li>
<li>树莓派 3 及以上版本支持从 U盘启动系统，但是需要先用 SD 卡启动后修改 boot 参数；</li>
<li>树莓派 3b+ 及以上版本支持 1000 Mbps 网卡；</li>
</ol>
<h1 id="2-u盘启动系统">2 U盘启动系统</h1>
<p>可以通过外部 U盘或者 SSD 进入系统，三种情况下有对应的<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=199414">系统速度测试</a>，默认的 SD 卡速度最慢。</p>
<p>所以这里<a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/msd.md">使用 U盘启动系统</a>（实际因为手头 U盘太多，SD 卡反而没几个）。</p>
<ol>
<li>使用 SD 卡进入系统；</li>
<li>执行 <code>echo program_usb_boot_mode=1 | sudo tee -a /boot/config.txt</code> 写入配置；</li>
<li>执行 <code>sudo reboot</code> 重启系统；</li>
<li>执行 <code>vcgencmd otp_dump | grep 17:</code> 查看是否成功，成功结果应该为 <code>17:3020000a</code>；</li>
<li>执行 <code>sudo poweroff</code> 关机，并断电；</li>
<li>拔出 SD 卡，插入烧录好系统的 U盘，上电启动；</li>
<li>进入 U盘系统；</li>
</ol>
<h1 id="3-设置键盘布局">3 设置键盘布局</h1>
<p>默认情况下，键盘布局为英式键盘布局，而我们常用的是美式键盘布局，很多键位是不一样的，所以需要更改键盘布局。</p>
<ol>
<li>执行 <code>sudo raspi-config</code>；</li>
<li>找到键盘布局更改选项，并执行；</li>
<li>选择 Generic 101-key pc；</li>
<li>选择 Other；</li>
<li>选择国家为 English(US)；</li>
<li>选择布局为 English(US)；</li>
<li>选择 The default for the keyboard layout；</li>
<li>选择 No compose key；</li>
<li>执行 <code>sudo reboot</code> 重启系统；</li>
</ol>
<h1 id="4-打开-ssh">4 打开 SSH</h1>
<p>默认情况下，SSH 是关闭的，即不能远程登录，所以需要打开 SSH 以提供远程登录。</p>
<ol>
<li>执行 <code>sudo raspi-config</code>；</li>
<li>找到 SSH 选项，选择打开；</li>
</ol>
<h1 id="5-配置-wifi">5 配置 WiFi</h1>
<ol>
<li>执行 <code>sudo raspi-config</code>；</li>
<li>找到 WiFi 选项；</li>
<li>输入 WiFi 名称和密码；</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu 下 Jenkins 安装与配置]]></title>
        <id>https://winking324.github.io/post/ubuntu-jenkins</id>
        <link href="https://winking324.github.io/post/ubuntu-jenkins">
        </link>
        <updated>2018-10-25T08:45:32.000Z</updated>
        <summary type="html"><![CDATA[<p>Jenkins 是一个开源软件项目，是基于 Java 开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Jenkins 是一个开源软件项目，是基于 Java 开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<!-- more -->
<h1 id="1-安装-java">1 安装 Java</h1>
<p>Jenkins 依赖于 Java， 所以需要<a href="http://www.webupd8.org/2012/09/install-oracle-java-8-in-ubuntu-via-ppa.html">安装 JDK 环境</a>。</p>
<ol>
<li>
<p>增加 java 源（只能装 Java8 版本，其他版本 Jenkins 不支持）；</p>
<pre><code class="language-sh">sudo add-apt-repository ppa:webupd8team/java
sudo apt update
</code></pre>
</li>
<li>
<p>安装 java 8；</p>
<pre><code class="language-sh">sudo apt install oracle-java8-installer
</code></pre>
<p>确认 License：</p>
<p><img src="https://winking324.github.io/post-images/1561193202986.png" alt=""></p>
<p><img src="https://winking324.github.io/post-images/1561193220461.png" alt=""></p>
</li>
<li>
<p>安装 java 环境设置；</p>
<pre><code class="language-sh">sudo apt install oracle-java8-set-default
</code></pre>
</li>
<li>
<p>验证 java 版本 &gt;= 1.8；</p>
<pre><code class="language-sh">java -version
</code></pre>
<p>出现以下结果：</p>
<pre><code class="language-sh">java version &quot;1.8.0_191&quot;
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)
</code></pre>
</li>
<li>
<p>打开编辑以下文件，设置 java 环境；</p>
<pre><code class="language-sh">sudo vi /etc/environment
</code></pre>
</li>
<li>
<p>输入 Java 环境设置，保存并关闭文件；</p>
<pre><code class="language-sh">JAVA_HOME=&quot;/usr/lib/jvm/java-8-oracle/&quot;
JRE_HOME=&quot;/usr/lib/jvm/java-8-oracle/jre/&quot;
</code></pre>
</li>
<li>
<p>更新环境设置；</p>
<pre><code class="language-sh">source /etc/environment
</code></pre>
</li>
</ol>
<h1 id="2-安装-jenkins">2 安装 Jenkins</h1>
<pre><code class="language-sh"># 1. 增加 Jenkins 源；
wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -
sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'
sudo apt-get update

# 2. 安装 Jenkins；
sudo apt-get install jenkins
</code></pre>
<h1 id="3-初始化-jenkins">3 初始化 Jenkins</h1>
<ol>
<li>
<p>修改 Jenkins 配置；</p>
<pre><code class="language-sh"># 1. 创建工作路径（方便迁移管理）；
sudo mkdir /data/jenkins
sudo chown -R jenkins:jenkins /data/jenkins

# 2. 打开编辑环境变量文件；
sudo vi /etc/environment

# 3. 配置 JENKINS_HOME 环境变量，并保存退出
JENKINS_HOME=&quot;/data/jenkins&quot;

# 4. 更新配置；
source /etc/environment

# 5. 重启 Jenkins 服务；
sudo service jenkins restart
</code></pre>
</li>
<li>
<p>查看初始密码；</p>
<pre><code class="language-sh">sudo cat $JENKINS_HOME/secrets/initialAdminPassword
</code></pre>
</li>
<li>
<p>登录 Jenkins；</p>
<p>打开浏览器，输入 <code>http://192.168.100.110:8080</code> 登录到 Jenkins，第一次登录需要初始密码。</p>
<p><img src="https://winking324.github.io/post-images/1561193245385.png" alt=""></p>
</li>
<li>
<p>安装插件，选择<code>建议安装的插件</code>即可，选择后等待安装；</p>
<p><img src="https://winking324.github.io/post-images/1561193273723.png" alt=""></p>
<p><img src="https://winking324.github.io/post-images/1561193302049.png" alt=""></p>
</li>
<li>
<p>创建Admin用户，点击保存并完成；</p>
<p><img src="https://winking324.github.io/post-images/1561193315181.png" alt=""></p>
</li>
<li>
<p>实例配置，点击保存并完成；</p>
<p><img src="https://winking324.github.io/post-images/1561193323980.png" alt=""></p>
</li>
<li>
<p>结束配置；</p>
<p><img src="https://winking324.github.io/post-images/1561193332769.png" alt=""></p>
</li>
<li>
<p>进入 Jenkins；</p>
<p><img src="https://winking324.github.io/post-images/1561193343039.png" alt=""></p>
</li>
</ol>
]]></content>
    </entry>
</feed>